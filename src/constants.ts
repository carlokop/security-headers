export const HEADERS_TO_CHECK = [
  'Strict-Transport-Security',
  'Content-Security-Policy',
  'X-Content-Type-Options',
  'X-Frame-Options',
  'Referrer-Policy',
  'Permissions-Policy',
  'X-XSS-Protection'
];

export const translations = {
  nl: {
    "meta": {
      "title": "Security Header Analyse | Gratis Website Veiligheidsscan",
      "description": "Controleer de HTTP security headers van uw website met onze gratis tool. Analyseer CSP, HSTS, en meer om kwetsbaarheden te vinden en uw site te beveiligen."
    },
    "header": {
      "title": "Security Header Analyse",
      "subtitle": "Controleer de beveiliging van elke website"
    },
    "form": {
      "label": "Website URL",
      "placeholder": "www.voorbeeld.nl",
      "button": {
        "analyze": "Analyseren",
        "analyzing": "Analyseren..."
      }
    },
    "results": {
      "title": "Resultaten voor",
      "value": {
        "notPresent": "Niet aanwezig"
      },
      "button": {
        "explanation": "Uitleg"
      }
    },
    "errors": {
      "unknown": "Een onbekende fout is opgetreden.",
      "analysisFailed": "Analyse mislukt. Zorg ervoor dat de URL correct is. Fout: {{errorMessage}}"
    },
    "seo": {
      "title": "Waarom zijn Security Headers Belangrijk?",
      "intro": "HTTP security headers zijn een fundamenteel onderdeel van websitebeveiliging. Ze stellen webservers in staat om browsers te instrueren hoe ze zich moeten gedragen bij het verwerken van de content van een website. Dit helpt bij het voorkomen van veelvoorkomende aanvallen zoals Cross-Site Scripting (XSS), clickjacking, en man-in-the-middle aanvallen. Door headers zoals <strong>Content-Security-Policy</strong>, <strong>Strict-Transport-Security</strong>, en <strong>X-Frame-Options</strong> correct te implementeren, voegt u een cruciale verdedigingslaag toe aan uw applicatie. Dit beschermt niet alleen uw website, maar ook de gegevens en de privacy van uw gebruikers.",
      "howItWorks": {
        "title": "Hoe Werkt Deze Tool?",
        "body": "Deze tool analyseert de URL die u invoert en controleert op de aanwezigheid en correcte configuratie van de belangrijkste security headers. We geven een duidelijk overzicht van welke headers aanwezig zijn en welke ontbreken. Daarnaast bieden we een gedetailleerde uitleg van het doel van elke header en de risico's die u loopt als deze niet aanwezig is. Gebruik deze analyse om de beveiliging van uw website te verbeteren."
      },
      "accordion": {
        "hsts": {
          "content": [
            "De <a href='https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Strict-Transport-Security' target='_blank' rel='noopener noreferrer' class='text-brand-secondary hover:underline'>HTTP Strict Transport Security (HSTS)</a> header is een krachtige beveiligingsmaatregel die websites beschermt tegen <a href='https://owasp.org/www-community/attacks/Man-in-the-middle_attack' target='_blank' rel='noopener noreferrer' class='text-brand-secondary hover:underline'>man-in-the-middle-aanvallen</a>, zoals protocol-downgrade-aanvallen en cookie-hijacking. In essentie is het een instructie van de webserver aan de browser om uitsluitend via een veilige, versleutelde HTTPS-verbinding te communiceren en nooit via het onveilige HTTP. Deze instructie wordt door de browser onthouden voor een door de website gespecificeerde periode.",
            "Het voornaamste gevaar dat HSTS aanpakt, is 'SSL stripping'. Stel u voor dat een gebruiker verbinding maakt met een openbaar Wi-Fi-netwerk in een koffiebar. Een aanvaller op hetzelfde netwerk kan de eerste, onbeveiligde HTTP-aanvraag van de gebruiker onderscheppen. Zelfs als de website normaal gesproken doorverwijst naar HTTPS, kan de aanvaller deze doorverwijzing blokkeren en een onversleutelde verbinding met de gebruiker onderhouden, terwijl hij zelf een versleutelde verbinding met de server opzet. De gebruiker merkt hier niets van, maar de aanvaller kan nu al het verkeer, inclusief wachtwoorden en persoonlijke gegevens, in platte tekst meelezen. HSTS voorkomt dit scenario volledig. Zodra een browser de HSTS-header van een domein heeft ontvangen, zal het alle toekomstige pogingen om via HTTP verbinding te maken, automatisch en intern omzetten naar HTTPS, nog voordat de aanvraag het netwerk verlaat. De aanvaller krijgt simpelweg nooit de kans om de verbinding te onderscheppen.",
            "De implementatie van HSTS gebeurt via de header zelf, die verschillende directieven kan bevatten. De belangrijkste is `max-age`, die in seconden aangeeft hoe lang de browser de HSTS-regel moet onthouden. Een typische aanbevolen waarde is 31536000, wat overeenkomt met één jaar. Een ander krachtig directief is `includeSubDomains`. Indien aanwezig, geldt de HSTS-regel niet alleen voor het hoofddomein (bijv. `www.voorbeeld.nl`), maar ook voor alle subdomeinen (zoals `blog.voorbeeld.nl` en `api.voorbeeld.nl`). Dit is een cruciale toevoeging, maar vereist wel dat alle subdomeinen volledig via HTTPS bereikbaar zijn. De ultieme bescherming wordt geboden door het `preload` directief. Als een website voldoet aan strenge eisen, kan het worden opgenomen in de <a href='https://hstspreload.org/' target='_blank' rel='noopener noreferrer' class='text-brand-secondary hover:underline'>'HSTS preload list'</a>, een lijst die hardcoded is in grote browsers zoals Chrome, Firefox en Safari. Dit betekent dat zelfs de allereerste verbinding van een gebruiker met de website direct wordt geforceerd naar HTTPS, waardoor er geen enkel venster van kwetsbaarheid overblijft."
          ]
        },
        "csp": {
          "content": [
            "De <a href='https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP' target='_blank' rel='noopener noreferrer' class='text-brand-secondary hover:underline'>Content-Security-Policy (CSP)</a> is een van de meest krachtige en essentiële verdedigingsmechanismen tegen een breed scala aan content-injectieaanvallen, met als voornaamste doel het mitigeren van <a href='https://owasp.org/www-community/attacks/xss/' target='_blank' rel='noopener noreferrer' class='text-brand-secondary hover:underline'>Cross-Site Scripting (XSS)</a>. In een notendop stelt CSP een websitebeheerder in staat om een strikte 'whitelist' van vertrouwde bronnen te definiëren. Alleen content die afkomstig is van deze expliciet goedgekeurde domeinen mag door de browser worden geladen en uitgevoerd. Dit omvat scripts, stylesheets, afbeeldingen, fonts, iframes en meer. Alles wat niet op deze lijst staat, wordt door de browser genadeloos geblokkeerd, waardoor de aanvalsvector voor veelvoorkomende kwetsbaarheden drastisch wordt verkleind.",
            "Om de kracht van CSP te begrijpen, moet men eerst de dreiging van XSS begrijpen. Een XSS-aanval vindt plaats wanneer een aanvaller erin slaagt kwaadaardige code, meestal JavaScript, te injecteren in een legitieme website. Dit kan gebeuren via een reactieveld, een zoekbalk of een gemanipuleerde URL. Wanneer een andere gebruiker de besmette pagina bezoekt, wordt dit script uitgevoerd in hun browser, met dezelfde rechten als de website zelf. De aanvaller kan hiermee sessie-cookies stelen, inloggegevens onderscheppen, de pagina visueel aanpassen of de gebruiker omleiden naar een phishing-site. CSP pakt dit probleem bij de wortel aan. Zelfs als een aanvaller een kwaadaardig script injecteert, zal een goed geconfigureerde CSP de browser instrueren om dit script niet uit te voeren, omdat het niet afkomstig is van een goedgekeurde bron. Standaard blokkeert CSP ook inline scripts en `eval()`-achtige functies, die veelgebruikte technieken zijn bij XSS-aanvallen.",
            "Het configureren van een CSP gebeurt via een reeks 'directieven' in de headerwaarde. Elk directief beheert een specifiek type content. Zo bepaalt `script-src` welke bronnen scripts mogen leveren, `style-src` regelt stylesheets, en `img-src` beheert afbeeldingen. Het `default-src` directief fungeert als een fallback voor de meeste andere directieven. Veelgebruikte bronwaarden zijn `'self'` (wat verwijst naar het eigen domein), specifieke domeinen (zoals `https://apis.google.com`), en `'none'` (wat niets toestaat). Het implementeren van een CSP vereist zorgvuldige planning, omdat een te strikte policy legitieme functionaliteit kan breken. Daarom biedt CSP ook een `report-only` modus. In deze modus worden overtredingen niet geblokkeerd, maar wordt er wel een rapport gestuurd naar een door de ontwikkelaar gespecificeerde URL via het `report-uri` of `report-to` directief. Dit stelt teams in staat om hun policy te testen en te verfijnen in een productieomgeving zonder de gebruikerservaring te verstoren."
          ]
        },
        "xcto": {
          "content": [
            "De <a href='https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Content-Type-Options' target='_blank' rel='noopener noreferrer' class='text-brand-secondary hover:underline'>`X-Content-Type-Options`</a> header is een schijnbaar eenvoudige, maar uiterst effectieve beveiligingsmaatregel die een specifieke en verraderlijke aanvalsvector blokkeert: MIME-type sniffing. Met slechts één mogelijke, geldige waarde, `nosniff`, geeft deze header een duidelijke en ondubbelzinnige instructie aan de browser: vertrouw de `Content-Type` header die door de server wordt meegestuurd en probeer onder geen enkele omstandigheid zelf te raden wat voor type bestand je ontvangt. Deze simpele regel is een fundamentele verdediging tegen een klasse van aanvallen die misbruik maken van de neiging van browsers om 'behulpzaam' te zijn.",
            "De kern van het probleem is <a href='https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types#mime_sniffing' target='_blank' rel='noopener noreferrer' class='text-brand-secondary hover:underline'>'MIME sniffing'</a>. Webservers sturen een `Content-Type` header mee met elk bestand om de browser te vertellen wat het is (bijv. `text/html`, `image/jpeg`, `application/javascript`). Oudere browsers probeerden echter soms slimmer te zijn dan de server. Als een server bijvoorbeeld een bestand stuurde met `Content-Type: text/plain`, maar de inhoud leek op HTML, dan kon de browser besluiten om het toch als HTML te renderen. Hoewel dit bedoeld was om verkeerd geconfigureerde servers te corrigeren, creëerde het een gevaarlijke kwetsbaarheid. Een aanvaller kan hier misbruik van maken door een bestand te uploaden dat op het eerste gezicht onschuldig lijkt, maar in werkelijkheid kwaadaardige code bevat.",
            "Een klassiek aanvalsscenario ziet er als volgt uit: een aanvaller uploadt een bestand naar een website, bijvoorbeeld als profielfoto. Dit bestand heeft de extensie `.jpg` en bevat geldige afbeeldingsdata, maar er is ook kwaadaardige JavaScript-code in verborgen. De server ziet de `.jpg`-extensie, vertrouwt dit, en serveert het bestand met `Content-Type: image/jpeg`. Wanneer een slachtoffer deze 'afbeelding' bekijkt, zou een browser zonder de `nosniff`-instructie het bestand kunnen inspecteren. De browser detecteert de JavaScript-code en besluit, ondanks de `Content-Type` header, dat het een script is en voert het uit. Omdat dit script wordt uitgevoerd binnen de context van de website, heeft het toegang tot de sessie van de gebruiker, wat kan leiden tot een volledige overname van het account via Cross-Site Scripting (XSS).",
            "De `X-Content-Type-Options: nosniff` header stopt deze aanval volledig. De browser krijgt nu de expliciete opdracht: 'Als de server zegt dat dit een `image/jpeg` is, behandel het dan als een afbeelding en niets anders.' De browser zal niet langer proberen de inhoud te 'sniffen' en zal de verborgen JavaScript-code negeren. De implementatie is triviaal – het is simpelweg het toevoegen van een enkele header aan alle serverantwoorden. Het is een perfect voorbeeld van een 'defense-in-depth' principe: zelfs als andere beveiligingslagen (zoals bestandsvalidatie bij het uploaden) falen, biedt deze header een robuuste laatste verdedigingslinie. Het is een essentiële, laagdrempelige maatregel die op elke moderne website aanwezig zou moeten zijn."
          ]
        },
        "xfo": {
          "content": [
            "De <a href='https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Frame-Options' target='_blank' rel='noopener noreferrer' class='text-brand-secondary hover:underline'>`X-Frame-Options`</a> header is een cruciale beveiligingsmaatregel die specifiek is ontworpen om een verraderlijke aanval genaamd <a href='https://owasp.org/www-community/attacks/Clickjacking' target='_blank' rel='noopener noreferrer' class='text-brand-secondary hover:underline'>'clickjacking'</a> te voorkomen. Clickjacking, ook wel bekend als een 'UI redress attack', is een techniek waarbij een aanvaller een gebruiker misleidt om op iets anders te klikken dan wat de gebruiker waarneemt. Dit wordt meestal bereikt door een onzichtbare of transparante webpagina (of een deel ervan) in een iframe over de zichtbare pagina te leggen. De gebruiker denkt dat hij op een onschuldige knop klikt, zoals 'Win een prijs', maar in werkelijkheid wordt zijn klik geregistreerd op de onzichtbare pagina eronder, bijvoorbeeld op een 'Verwijder mijn account' knop van een website waarop hij op dat moment is ingelogd.",
            "De `X-Frame-Options` header biedt een eenvoudige maar effectieve manier om te bepalen of een browser een pagina mag weergeven binnen inbeddingselementen zoals frames of iframes. Door deze header in de HTTP-respons van een webpagina op te nemen, kan de server de browser instrueren hoe deze verzoeken moet behandelen. Er zijn twee veelgebruikte, en één verouderde, directieven die kunnen worden gebruikt. De meest restrictieve en veiligste optie is `DENY`. Deze waarde verbiedt het weergeven van de pagina in een frame volledig, ongeacht welke website dit probeert te doen. Dit is de beste keuze voor pagina's met zeer gevoelige acties die nooit ingebed zouden moeten worden, zoals pagina's voor het wijzigen van wachtwoorden of het uitvoeren van financiële transacties.",
            "Een meer flexibele, en zeer gangbare, optie is `SAMEORIGIN`. Dit directief staat toe dat de pagina in een frame wordt weergegeven, maar alleen als de website die de pagina probeert in te bedden, dezelfde oorsprong (domein) heeft als de pagina zelf. Dit is bijzonder nuttig voor webapplicaties die iframes gebruiken voor hun eigen legitieme functionaliteit, zoals het tonen van modale vensters of het integreren van verschillende onderdelen van dezelfde applicatie, terwijl het inbedden door externe, potentieel kwaadaardige websites wordt voorkomen. Een derde, verouderde optie is `ALLOW-FROM uri`, waarmee een specifieke URL kon worden opgegeven die de pagina mocht framen. Deze optie is echter nooit breed ondersteund door alle browsers en wordt nu als verouderd beschouwd.",
            "Hoewel `X-Frame-Options` nog steeds zeer relevant en effectief is, is het belangrijk op te merken dat de modernere `Content-Security-Policy` (CSP) een <a href='https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/frame-ancestors' target='_blank' rel='noopener noreferrer' class='text-brand-secondary hover:underline'>`frame-ancestors`</a> directief bevat. Dit directief wordt beschouwd als de opvolger van `X-Frame-Options`, omdat het meer flexibiliteit biedt (zoals het specificeren van meerdere toegestane domeinen). Echter, vanwege de brede ondersteuning en eenvoud, blijft het implementeren van `X-Frame-Options` een aanbevolen 'defense-in-depth' strategie, vooral om compatibiliteit met oudere browsers te garanderen. Door deze header correct te configureren, wordt een hele klasse van UI-gebaseerde aanvallen effectief geneutraliseerd."
          ]
        },
        "rp": {
          "content": [
            "De <a href='https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Referrer-Policy' target='_blank' rel='noopener noreferrer' class='text-brand-secondary hover:underline'>`Referrer-Policy`</a> header is een essentieel instrument voor het beschermen van de privacy van gebruikers door te bepalen welke informatie wordt meegestuurd in de `Referer`-header (let op de historische spelfout) wanneer een gebruiker van de ene naar de andere pagina navigeert. Standaard stuurt een browser de volledige URL van de vorige pagina mee naar de nieuwe pagina. Hoewel dit nuttig is voor analytics en het begrijpen van verkeersstromen, creëert het een aanzienlijk privacyrisico. URL's kunnen gevoelige informatie bevatten, zoals zoektermen, gebruikers-ID's, of zelfs tokens voor het resetten van wachtwoorden. Het doorsturen van deze data naar externe partijen, zonder medeweten van de gebruiker, is een datalek dat kan worden misbruikt.",
            "De `Referrer-Policy` geeft website-eigenaren de mogelijkheid om dit gedrag nauwkeurig te sturen met behulp van verschillende directieven. De keuze voor een directief is een afweging tussen privacy en functionaliteit. Een van de strengste opties is `no-referrer`. Zoals de naam al aangeeft, wordt de `Referer`-header in dit geval volledig weggelaten bij alle uitgaande verzoeken. Dit biedt maximale privacy, maar maakt het voor de ontvangende site onmogelijk om te zien waar het verkeer vandaan komt, wat de analyse van verkeersbronnen kan bemoeilijken. Een andere veelgebruikte, privacyvriendelijke optie is `strict-origin-when-cross-origin`. Dit is vaak een goede standaardkeuze. Het gedraagt zich als volgt: bij navigatie binnen dezelfde website (bijv. van `voorbeeld.nl/pagina1` naar `voorbeeld.nl/pagina2`) wordt de volledige URL meegestuurd. Echter, bij navigatie naar een andere website (cross-origin), wordt alleen de basis-URL (de origin, bijv. `https://voorbeeld.nl/`) meegestuurd, en alleen als de verbinding even veilig is (HTTPS naar HTTPS).",
            "Andere directieven bieden meer granulaire controle. `same-origin` zorgt ervoor dat de referrer alleen wordt meegestuurd voor verzoeken binnen dezelfde website; voor alle andere verzoeken wordt deze weggelaten. `strict-origin` stuurt alleen de basis-URL mee, maar doet dit, in tegenstelling tot `strict-origin-when-cross-origin`, ook voor navigatie binnen dezelfde site. Aan de andere kant van het spectrum staat `unsafe-url`, wat, zoals de naam al aangeeft, onveilig is. Dit directief stuurt altijd de volledige URL mee, inclusief queryparameters, zelfs bij onveilige (HTTP) verzoeken. Het gebruik hiervan wordt sterk afgeraden. Door bewust een `Referrer-Policy` te kiezen, nemen website-eigenaren de verantwoordelijkheid voor de data van hun gebruikers. Het implementeren van een restrictieve policy, zoals `strict-origin-when-cross-origin`, is een eenvoudige stap die de privacy aanzienlijk verbetert zonder essentiële functionaliteit te breken."
          ]
        },
        "pp": {
          "content": [
            "De <a href='https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Permissions-Policy' target='_blank' rel='noopener noreferrer' class='text-brand-secondary hover:underline'>`Permissions-Policy`</a> header is een moderne en krachtige beveiligingsfunctie die websitebeheersers gedetailleerde controle geeft over welke browserfuncties en API's op een pagina gebruikt mogen worden. Deze header, die de oudere `Feature-Policy` vervangt, is gebaseerd op het 'principle of least privilege': een stuk code zou alleen de rechten moeten hebben die absoluut noodzakelijk zijn om zijn taak uit te voeren. Door expliciet te definiëren welke functies zijn toegestaan, kunnen ontwikkelaars de 'attack surface' van hun website aanzienlijk verkleinen en de privacy van gebruikers beter beschermen.",
            "Moderne webapplicaties maken steeds vaker gebruik van krachtige browser-API's, zoals toegang tot de camera (`camera`), microfoon (`microphone`), geolocatie (`geolocation`), fullscreen-modus (`fullscreen`), en het verwerken van betalingen (`payment`). Hoewel deze functies innovatieve gebruikerservaringen mogelijk maken, vormen ze ook een potentieel risico. Een kwetsbaarheid in een script van derden, zoals een advertentie- of analytics-script dat op uw pagina wordt geladen, zou misbruikt kunnen worden om ongewenst toegang te krijgen tot deze gevoelige API's. Een gebruiker zou bijvoorbeeld onbewust kunnen worden gevraagd om microfoontoegang te verlenen aan een onbetrouwbaar script dat meelift op uw legitieme website.",
            "De `Permissions-Policy` pakt dit probleem aan door een duidelijk beleid te specificeren. De header bestaat uit een reeks directieven, waarbij elk directief een specifieke functie vertegenwoordigt. Voor elke functie kan een lijst van toegestane 'origins' (domeinen) worden opgegeven. Als een website bijvoorbeeld geen toegang tot de microfoon nodig heeft, kan de ontwikkelaar dit expliciet uitschakelen met `permissions-policy: microphone=()`. De lege haakjes `()` betekenen dat de functie voor alle partijen (inclusief de eigen site en alle iframes) is uitgeschakeld. Als een functie alleen door de eigen website gebruikt mag worden, kan dit worden ingesteld met `microphone=('self')`. Dit zorgt ervoor dat ingebedde iframes van derden, zoals een YouTube-video, geen toegang tot de microfoon kunnen vragen.",
            "De echte kracht van `Permissions-Policy` ligt in de granulaire controle over content van derden. U kunt een specifiek domein toestemming geven, bijvoorbeeld `permissions-policy: camera=('self' https://trusted-partner.com)`. Dit zorgt ervoor dat alleen uw eigen site en een vertrouwde partner de camera mogen gebruiken. Alle andere iframes worden geblokkeerd. Het implementeren van een strikte `Permissions-Policy` is een best practice voor moderne webontwikkeling. Het dwingt ontwikkelaars om bewust na te denken over welke functionaliteit hun applicatie echt nodig heeft en biedt een robuuste verdedigingslaag tegen misbruik van browser-API's. Dit resulteert in een veiligere ervaring voor de gebruiker en versterkt het vertrouwen in uw platform."
          ]
        },
        "xxp": {
          "content": [
            "De <a href='https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-XSS-Protection' target='_blank' rel='noopener noreferrer' class='text-brand-secondary hover:underline'>`X-XSS-Protection`</a> header is een stukje internetgeschiedenis; een beveiligingsmaatregel die ooit werd geïntroduceerd in browsers als Internet Explorer, Chrome en Safari als een eerste verdedigingslinie tegen 'reflected' Cross-Site Scripting (XSS) aanvallen. Hoewel de intentie goed was, is de header inmiddels verouderd en wordt deze door alle moderne browsers afgeraden en zelfs genegeerd. De functionaliteit is volledig vervangen door de veel robuustere en configureerbare `Content-Security-Policy` (CSP). Het begrijpen van de werking en de tekortkomingen van `X-XSS-Protection` biedt echter waardevol inzicht in de evolutie van webbeveiliging.",
            "De header was ontworpen om een specifieke aanvalsvector te blokkeren: een <a href='https://owasp.org/www-community/attacks/xss/#reflected-xss-attacks' target='_blank' rel='noopener noreferrer' class='text-brand-secondary hover:underline'>'reflected' XSS-aanval</a>. Dit type aanval vindt plaats wanneer kwaadaardige code, via een URL-parameter of formulierinvoer, door de server wordt 'gereflecteerd' en direct in de HTML-respons wordt opgenomen. De `X-XSS-Protection` header activeerde een ingebouwde 'auditor' of 'filter' in de browser. Deze filter gebruikte heuristieken om te detecteren of scriptcode in de aanvraag (bijvoorbeeld in de URL) ook letterlijk in de HTML van de pagina verscheen. Als dit het geval was, concludeerde de browser dat er een aanval plaatsvond.",
            "De header kon verschillende waarden hebben. De standaardwaarde was `1`, wat de filter activeerde. Bij detectie van een aanval probeerde de browser de pagina te 'saneren' door de kwaadaardige code te verwijderen of te neutraliseren. Dit bleek echter een gevaarlijke aanpak. Aanvallers ontdekten manieren om deze saneringsmechanismen te omzeilen en konden in sommige gevallen zelfs kwetsbaarheden creëren die zonder de filter niet bestonden. Een veiligere optie was `1; mode=block`. In deze modus zou de browser, bij het detecteren van een aanval, het renderen van de pagina volledig stoppen en een lege pagina tonen. Dit voorkwam de uitvoering van het script, maar bood een slechte gebruikerservaring. De waarde `0` schakelde de filter expliciet uit.",
            "Uiteindelijk werd de header afgeschaft om meerdere redenen. De filters waren onbetrouwbaar, konden worden omzeild, en veroorzaakten soms 'false positives' die legitieme websites braken. Belangrijker nog, de opkomst van `Content-Security-Policy` bood een fundamenteel superieure aanpak. In plaats van te proberen aanvallen te 'raden' op basis van onbetrouwbare heuristieken, stelt CSP ontwikkelaars in staat om een strikte 'whitelist' van vertrouwde codebronnen te definiëren. Dit 'deny by default'-model is inherent veiliger. Hoewel u de `X-XSS-Protection` header nog steeds op oudere websites kunt tegenkomen, is het voor moderne webontwikkeling geen actieve beveiligingsmaatregel meer. De focus ligt nu volledig op een sterke en goed geconfigureerde CSP."
          ]
        }
      }
    }
  },
  en: {
    "meta": {
      "title": "Security Header Analysis | Free Website Security Scan",
      "description": "Check your website's HTTP security headers with our free tool. Analyze CSP, HSTS, and more to find vulnerabilities and secure your site."
    },
    "header": {
      "title": "Security Header Analysis",
      "subtitle": "Check the security of any website"
    },
    "form": {
      "label": "Website URL",
      "placeholder": "www.example.com",
      "button": {
        "analyze": "Analyze",
        "analyzing": "Analyzing..."
      }
    },
    "results": {
      "title": "Results for",
      "value": {
        "notPresent": "Not present"
      },
      "button": {
        "explanation": "Explanation"
      }
    },
    "errors": {
      "unknown": "An unknown error occurred.",
      "analysisFailed": "Analysis failed. Ensure the URL is correct. Error: {{errorMessage}}"
    },
    "seo": {
      "title": "Why Are Security Headers Important?",
      "intro": "HTTP security headers are a fundamental part of website security. They allow web servers to instruct browsers on how to behave when handling a website's content. This helps prevent common attacks such as Cross-Site Scripting (XSS), clickjacking, and man-in-the-middle attacks. By correctly implementing headers like <strong>Content-Security-Policy</strong>, <strong>Strict-Transport-Security</strong>, and <strong>X-Frame-Options</strong>, you add a crucial layer of defense to your application. This not only protects your website but also the data and privacy of your users.",
      "howItWorks": {
        "title": "How Does This Tool Work?",
        "body": "This tool analyzes the URL you enter and checks for the presence and correct configuration of the most important security headers. We provide a clear overview of which headers are present and which are missing. Additionally, we offer a detailed explanation of the purpose of each header and the risks you run if it is not present. Use this analysis to improve your website's security."
      },
      "accordion": {
        "hsts": {
          "content": [
            "The <a href='https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Strict-Transport-Security' target='_blank' rel='noopener noreferrer' class='text-brand-secondary hover:underline'>HTTP Strict Transport Security (HSTS)</a> header is a powerful security measure that protects websites against <a href='https://owasp.org/www-community/attacks/Man-in-the-middle_attack' target='_blank' rel='noopener noreferrer' class='text-brand-secondary hover:underline'>man-in-the-middle attacks</a>, such as protocol downgrade attacks and cookie hijacking. In essence, it is an instruction from the web server to the browser to communicate exclusively via a secure, encrypted HTTPS connection and never via insecure HTTP. This instruction is remembered by the browser for a period specified by the website.",
            "The primary danger that HSTS addresses is 'SSL stripping'. Imagine a user connecting to a public Wi-Fi network at a coffee shop. An attacker on the same network can intercept the user's first, unsecured HTTP request. Even if the website normally redirects to HTTPS, the attacker can block this redirection and maintain an unencrypted connection with the user, while establishing an encrypted connection with the server themselves. The user notices nothing, but the attacker can now read all traffic, including passwords and personal data, in plain text. HSTS prevents this scenario completely. Once a browser has received the HSTS header from a domain, it will automatically and internally convert all future attempts to connect via HTTP to HTTPS before the request even leaves the network. The attacker simply never gets the chance to intercept the connection.",
            "The implementation of HSTS is done via the header itself, which can contain several directives. The most important is `max-age`, which specifies in seconds how long the browser should remember the HSTS rule. A typical recommended value is 31536000, which corresponds to one year. Another powerful directive is `includeSubDomains`. If present, the HSTS rule applies not only to the main domain (e.g., `www.example.com`) but also to all subdomains (such as `blog.example.com` and `api.example.com`). This is a crucial addition, but it requires that all subdomains are fully accessible via HTTPS. The ultimate protection is provided by the `preload` directive. If a website meets strict requirements, it can be included in the <a href='https://hstspreload.org/' target='_blank' rel='noopener noreferrer' class='text-brand-secondary hover:underline'>'HSTS preload list'</a>, a list that is hardcoded into major browsers like Chrome, Firefox, and Safari. This means that even the very first connection a user makes to the website is immediately forced to HTTPS, leaving no window of vulnerability."
          ]
        },
        "csp": {
          "content": [
            "The <a href='https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP' target='_blank' rel='noopener noreferrer' class='text-brand-secondary hover:underline'>Content-Security-Policy (CSP)</a> is one of the most powerful and essential defense mechanisms against a wide range of content injection attacks, with the primary goal of mitigating <a href='https://owasp.org/www-community/attacks/xss/' target='_blank' rel='noopener noreferrer' class='text-brand-secondary hover:underline'>Cross-Site Scripting (XSS)</a>. In a nutshell, CSP allows a website administrator to define a strict 'whitelist' of trusted sources. Only content originating from these explicitly approved domains may be loaded and executed by the browser. This includes scripts, stylesheets, images, fonts, iframes, and more. Anything not on this list is mercilessly blocked by the browser, drastically reducing the attack surface for common vulnerabilities.",
            "To understand the power of CSP, one must first understand the threat of XSS. An XSS attack occurs when an attacker manages to inject malicious code, usually JavaScript, into a legitimate website. This can happen via a comment field, a search bar, or a manipulated URL. When another user visits the infected page, this script is executed in their browser with the same permissions as the website itself. The attacker can use this to steal session cookies, capture keystrokes, visually modify the page, or redirect the user to a phishing site. CSP tackles this problem at its root. Even if an attacker injects a malicious script, a well-configured CSP will instruct the browser not to execute it because it does not come from an approved source. By default, CSP also blocks inline scripts and `eval()`-like functions, which are common techniques in XSS attacks.",
            "Configuring a CSP is done through a series of 'directives' in the header value. Each directive manages a specific type of content. For example, `script-src` determines which sources can supply scripts, `style-src` controls stylesheets, and `img-src` manages images. The `default-src` directive acts as a fallback for most other directives. Common source values are `'self'` (which refers to the own domain), specific domains (like `https://apis.google.com`), and `'none'` (which allows nothing). Implementing a CSP requires careful planning, as a policy that is too strict can break legitimate functionality. Therefore, CSP also offers a `report-only` mode. In this mode, violations are not blocked, but a report is sent to a developer-specified URL via the `report-uri` or `report-to` directive. This allows teams to test and refine their policy in a production environment without disrupting the user experience."
          ]
        },
        "xcto": {
          "content": [
            "The <a href='https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Content-Type-Options' target='_blank' rel='noopener noreferrer' class='text-brand-secondary hover:underline'>`X-Content-Type-Options`</a> header is a seemingly simple, yet extremely effective security measure that blocks a specific and insidious attack vector: MIME type sniffing. With only one possible, valid value, `nosniff`, this header gives a clear and unambiguous instruction to the browser: trust the `Content-Type` header sent by the server and under no circumstances try to guess the file type yourself. This simple rule is a fundamental defense against a class of attacks that exploit the tendency of browsers to be 'helpful'.",
            "The core of the problem is <a href='https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types#mime_sniffing' target='_blank' rel='noopener noreferrer' class='text-brand-secondary hover:underline'>'MIME sniffing'</a>. Web servers send a `Content-Type` header with every file to tell the browser what it is (e.g., `text/html`, `image/jpeg`, `application/javascript`). However, older browsers sometimes tried to be smarter than the server. For example, if a server sent a file with `Content-Type: text/plain`, but the content looked like HTML, the browser might decide to render it as HTML anyway. Although this was intended to correct misconfigured servers, it created a dangerous vulnerability. An attacker can exploit this by uploading a file that appears harmless at first glance but actually contains malicious code.",
            "A classic attack scenario is as follows: an attacker uploads a file to a website, for example, as a profile picture. This file has a `.jpg` extension and contains valid image data, but malicious JavaScript code is also hidden inside. The server sees the `.jpg` extension, trusts it, and serves the file with `Content-Type: image/jpeg`. When a victim views this 'image', a browser without the `nosniff` instruction might inspect the file. The browser detects the JavaScript code and decides, despite the `Content-Type` header, that it is a script and executes it. Because this script is executed within the context of the website, it has access to the user's session, which can lead to a full account takeover via Cross-Site Scripting (XSS).",
            "The `X-Content-Type-Options: nosniff` header stops this attack completely. The browser is now given the explicit command: 'If the server says this is an `image/jpeg`, treat it as an image and nothing else.' The browser will no longer try to 'sniff' the content and will ignore the hidden JavaScript code. The implementation is trivial – it's simply adding a single header to all server responses. It is a perfect example of a 'defense-in-depth' principle: even if other security layers (like file validation on upload) fail, this header provides a robust final line of defense. It is an essential, low-effort measure that should be present on every modern website."
          ]
        },
        "xfo": {
          "content": [
            "The <a href='https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Frame-Options' target='_blank' rel='noopener noreferrer' class='text-brand-secondary hover:underline'>`X-Frame-Options`</a> header is a crucial security measure specifically designed to prevent an insidious attack called <a href='https://owasp.org/www-community/attacks/Clickjacking' target='_blank' rel='noopener noreferrer' class='text-brand-secondary hover:underline'>'clickjacking'</a>. Clickjacking, also known as a 'UI redress attack', is a technique where an attacker tricks a user into clicking something different from what the user perceives. This is usually achieved by layering an invisible or transparent webpage (or part of it) in an iframe over the visible page. The user thinks they are clicking an innocent button, like 'Win a prize', but in reality, their click is registered on the invisible page underneath, for example, on a 'Delete my account' button of a website they are currently logged into.",
            "The `X-Frame-Options` header provides a simple but effective way to control whether a browser is allowed to render a page within embedding elements like frames or iframes. By including this header in a webpage's HTTP response, the server can instruct the browser on how to handle such requests. There are two commonly used, and one obsolete, directives. The most restrictive and safest option is `DENY`. This value completely forbids rendering the page in a frame, regardless of which website tries to do so. This is the best choice for pages with highly sensitive actions that should never be embedded, such as password change pages or financial transaction pages.",
            "A more flexible, and very common, option is `SAMEORIGIN`. This directive allows the page to be rendered in a frame, but only if the website attempting to embed the page has the same origin (domain) as the page itself. This is particularly useful for web applications that use iframes for their own legitimate functionality, such as displaying modal windows or integrating different parts of the same application, while preventing embedding by external, potentially malicious websites. A third, obsolete option is `ALLOW-FROM uri`, which allowed specifying a specific URL that was permitted to frame the page. However, this option was never widely supported by all browsers and is now considered obsolete.",
            "While `X-Frame-Options` is still very relevant and effective, it is important to note that the more modern `Content-Security-Policy` (CSP) includes a <a href='https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/frame-ancestors' target='_blank' rel='noopener noreferrer' class='text-brand-secondary hover:underline'>`frame-ancestors`</a> directive. This directive is considered the successor to `X-Frame-Options` as it offers more flexibility (such as specifying multiple allowed domains). However, due to its wide support and simplicity, implementing `X-Frame-Options` remains a recommended 'defense-in-depth' strategy, especially to ensure compatibility with older browsers. By correctly configuring this header, an entire class of UI-based attacks is effectively neutralized."
          ]
        },
        "rp": {
          "content": [
            "The <a href='https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Referrer-Policy' target='_blank' rel='noopener noreferrer' class='text-brand-secondary hover:underline'>`Referrer-Policy`</a> header is an essential tool for protecting user privacy by controlling what information is sent in the `Referer` header (note the historical misspelling) when a user navigates from one page to another. By default, a browser sends the full URL of the previous page to the new page. While this is useful for analytics and understanding traffic flows, it creates a significant privacy risk. URLs can contain sensitive information, such as search terms, user IDs, or even password reset tokens. Forwarding this data to external parties without the user's knowledge is a data leak that can be exploited.",
            "The `Referrer-Policy` allows website owners to precisely control this behavior using various directives. The choice of a directive is a trade-off between privacy and functionality. One of the strictest options is `no-referrer`. As the name suggests, the `Referer` header is completely omitted from all outgoing requests in this case. This provides maximum privacy but makes it impossible for the receiving site to see where the traffic is coming from, which can complicate traffic source analysis. Another common, privacy-friendly option is `strict-origin-when-cross-origin`. This is often a good default choice. It behaves as follows: for navigation within the same website (e.g., from `example.com/page1` to `example.com/page2`), the full URL is sent. However, for navigation to another website (cross-origin), only the base URL (the origin, e.g., `https://example.com/`) is sent, and only if the connection is equally secure (HTTPS to HTTPS).",
            "Other directives offer more granular control. `same-origin` ensures that the referrer is only sent for requests within the same website; it is omitted for all other requests. `strict-origin` sends only the base URL, but unlike `strict-origin-when-cross-origin`, it also does this for navigation within the same site. At the other end of the spectrum is `unsafe-url`, which, as the name implies, is unsafe. This directive always sends the full URL, including query parameters, even on insecure (HTTP) requests. Its use is strongly discouraged. By consciously choosing a `Referrer-Policy`, website owners take responsibility for their users' data. Implementing a restrictive policy, such as `strict-origin-when-cross-origin`, is a simple step that significantly improves privacy without breaking essential functionality."
          ]
        },
        "pp": {
          "content": [
            "The <a href='https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Permissions-Policy' target='_blank' rel='noopener noreferrer' class='text-brand-secondary hover:underline'>`Permissions-Policy`</a> header is a modern and powerful security feature that gives website administrators detailed control over which browser features and APIs can be used on a page. This header, which replaces the older `Feature-Policy`, is based on the 'principle of least privilege': a piece of code should only have the permissions absolutely necessary to perform its task. By explicitly defining which features are allowed, developers can significantly reduce their website's 'attack surface' and better protect user privacy.",
            "Modern web applications increasingly use powerful browser APIs, such as access to the camera (`camera`), microphone (`microphone`), geolocation (`geolocation`), fullscreen mode (`fullscreen`), and payment processing (`payment`). While these features enable innovative user experiences, they also pose a potential risk. A vulnerability in a third-party script, such as an advertising or analytics script loaded on your page, could be exploited to gain unwanted access to these sensitive APIs. For example, a user could be unknowingly prompted to grant microphone access to an untrustworthy script piggybacking on your legitimate website.",
            "The `Permissions-Policy` addresses this problem by specifying a clear policy. The header consists of a series of directives, where each directive represents a specific feature. For each feature, a list of allowed 'origins' (domains) can be specified. For example, if a website does not need access to the microphone, the developer can explicitly disable it with `permissions-policy: microphone=()`. The empty parentheses `()` mean the feature is disabled for all parties (including the own site and all iframes). If a feature should only be used by the own website, it can be set with `microphone=('self')`. This ensures that embedded iframes from third parties, such as a YouTube video, cannot request microphone access.",
            "The real power of `Permissions-Policy` lies in its granular control over third-party content. You can grant permission to a specific domain, for example, `permissions-policy: camera=('self' https://trusted-partner.com)`. This ensures that only your own site and a trusted partner can use the camera. All other iframes will be blocked. Implementing a strict `Permissions-Policy` is a best practice for modern web development. It forces developers to consciously think about what functionality their application really needs and provides a robust defense layer against the abuse of browser APIs. This results in a safer experience for the user and strengthens trust in your platform."
          ]
        },
        "xxp": {
          "content": [
            "The <a href='https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-XSS-Protection' target='_blank' rel='noopener noreferrer' class='text-brand-secondary hover:underline'>`X-XSS-Protection`</a> header is a piece of internet history; a security measure once introduced in browsers like Internet Explorer, Chrome, and Safari as a first line of defense against 'reflected' Cross-Site Scripting (XSS) attacks. Although the intention was good, the header is now obsolete and is deprecated and even ignored by all modern browsers. Its functionality has been completely replaced by the much more robust and configurable `Content-Security-Policy` (CSP). However, understanding the operation and shortcomings of `X-XSS-Protection` provides valuable insight into the evolution of web security.",
            "The header was designed to block a specific attack vector: a <a href='https://owasp.org/www-community/attacks/xss/#reflected-xss-attacks' target='_blank' rel='noopener noreferrer' class='text-brand-secondary hover:underline'>'reflected' XSS attack</a>. This type of attack occurs when malicious code, via a URL parameter or form input, is 'reflected' by the server and included directly in the HTML response. The `X-XSS-Protection` header activated a built-in 'auditor' or 'filter' in the browser. This filter used heuristics to detect if script code in the request (e.g., in the URL) also appeared literally in the page's HTML. If so, the browser concluded that an attack was taking place.",
            "The header could have several values. The default value was `1`, which activated the filter. Upon detecting an attack, the browser would try to 'sanitize' the page by removing or neutralizing the malicious code. However, this proved to be a dangerous approach. Attackers discovered ways to bypass these sanitization mechanisms and, in some cases, could even create vulnerabilities that did not exist without the filter. A safer option was `1; mode=block`. In this mode, upon detecting an attack, the browser would stop rendering the page completely and show a blank page. This prevented the script from executing but provided a poor user experience. The value `0` explicitly disabled the filter.",
            "Ultimately, the header was deprecated for several reasons. The filters were unreliable, could be bypassed, and sometimes caused 'false positives' that broke legitimate websites. More importantly, the rise of `Content-Security-Policy` offered a fundamentally superior approach. Instead of trying to 'guess' attacks based on unreliable heuristics, CSP allows developers to define a strict 'whitelist' of trusted code sources. This 'deny by default' model is inherently safer. Although you may still encounter the `X-XSS-Protection` header on older websites, it is no longer considered an active security measure for modern web development. The focus is now entirely on a strong and well-configured CSP."
          ]
        }
      }
    }
  },
  de: {
    "meta": {
      "title": "Sicherheitsheader-Analyse | Kostenloser Website-Sicherheits-Scan",
      "description": "Überprüfen Sie die HTTP-Sicherheitsheader Ihrer Website mit unserem kostenlosen Tool. Analysieren Sie CSP, HSTS und mehr, um Schwachstellen zu finden und Ihre Website zu sichern."
    },
    "header": {
      "title": "Analyse der Sicherheitsheader",
      "subtitle": "Überprüfen Sie die Sicherheit jeder Website"
    },
    "form": {
      "label": "Website-URL",
      "placeholder": "www.beispiel.de",
      "button": {
        "analyze": "Analysieren",
        "analyzing": "Analysiere..."
      }
    },
    "results": {
      "title": "Ergebnisse für",
      "value": {
        "notPresent": "Nicht vorhanden"
      },
      "button": {
        "explanation": "Erklärung"
      }
    },
    "errors": {
      "unknown": "Ein unbekannter Fehler ist aufgetreten.",
      "analysisFailed": "Analyse fehlgeschlagen. Stellen Sie sicher, dass die URL korrekt ist. Fehler: {{errorMessage}}"
    },
    "seo": {
      "title": "Warum sind Sicherheitsheader wichtig?",
      "intro": "HTTP-Sicherheitsheader sind ein fundamentaler Bestandteil der Website-Sicherheit. Sie ermöglichen es Webservern, Browsern Anweisungen zu geben, wie sie sich beim Verarbeiten des Inhalts einer Website verhalten sollen. Dies hilft, häufige Angriffe wie Cross-Site Scripting (XSS), Clickjacking und Man-in-the-Middle-Angriffe zu verhindern. Durch die korrekte Implementierung von Headern wie <strong>Content-Security-Policy</strong>, <strong>Strict-Transport-Security</strong> und <strong>X-Frame-Options</strong> fügen Sie Ihrer Anwendung eine entscheidende Verteidigungsschicht hinzu. Dies schützt nicht nur Ihre Website, sondern auch die Daten und die Privatsphäre Ihrer Benutzer.",
      "howItWorks": {
        "title": "Wie funktioniert dieses Tool?",
        "body": "Dieses Tool analysiert die von Ihnen eingegebene URL und prüft das Vorhandensein und die korrekte Konfiguration der wichtigsten Sicherheitsheader. Wir bieten einen klaren Überblick darüber, welche Header vorhanden sind und welche fehlen. Zusätzlich bieten wir eine detaillierte Erklärung zum Zweck jedes Headers und den Risiken, die Sie eingehen, wenn dieser nicht vorhanden ist. Nutzen Sie diese Analyse, um die Sicherheit Ihrer Website zu verbessern."
      },
      "accordion": {
        "hsts": {
          "content": [
            "Der <a href='https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Strict-Transport-Security' target='_blank' rel='noopener noreferrer' class='text-brand-secondary hover:underline'>HTTP Strict Transport Security (HSTS)</a>-Header ist eine leistungsstarke Sicherheitsmaßnahme, die Websites vor <a href='https://owasp.org/www-community/attacks/Man-in-the-middle_attack' target='_blank' rel='noopener noreferrer' class='text-brand-secondary hover:underline'>Man-in-the-Middle-Angriffen</a> schützt, wie z.B. Protokoll-Downgrade-Angriffen und Cookie-Hijacking. Im Wesentlichen ist es eine Anweisung vom Webserver an den Browser, ausschließlich über eine sichere, verschlüsselte HTTPS-Verbindung zu kommunizieren und niemals über das unsichere HTTP. Diese Anweisung wird vom Browser für einen von der Website festgelegten Zeitraum gespeichert.",
            "Die Hauptgefahr, der HSTS begegnet, ist das 'SSL-Stripping'. Stellen Sie sich vor, ein Benutzer verbindet sich mit einem öffentlichen WLAN-Netzwerk in einem Café. Ein Angreifer im selben Netzwerk kann die erste, ungesicherte HTTP-Anfrage des Benutzers abfangen. Selbst wenn die Website normalerweise auf HTTPS umleitet, kann der Angreifer diese Umleitung blockieren und eine unverschlüsselte Verbindung zum Benutzer aufrechterhalten, während er selbst eine verschlüsselte Verbindung zum Server herstellt. Der Benutzer bemerkt davon nichts, aber der Angreifer kann nun den gesamten Verkehr, einschließlich Passwörtern und persönlichen Daten, im Klartext mitlesen. HSTS verhindert dieses Szenario vollständig. Sobald ein Browser den HSTS-Header von einer Domain erhalten hat, wandelt er alle zukünftigen Versuche, sich über HTTP zu verbinden, automatisch und intern in HTTPS um, noch bevor die Anfrage das Netzwerk verlässt. Der Angreifer bekommt einfach nie die Chance, die Verbindung abzufangen.",
            "Die Implementierung von HSTS erfolgt über den Header selbst, der mehrere Direktiven enthalten kann. Die wichtigste ist `max-age`, die in Sekunden angibt, wie lange der Browser die HSTS-Regel speichern soll. Ein typischer empfohlener Wert ist 31536000, was einem Jahr entspricht. Eine weitere leistungsstarke Direktive ist `includeSubDomains`. Wenn vorhanden, gilt die HSTS-Regel nicht nur für die Hauptdomain (z.B. `www.beispiel.de`), sondern auch für alle Subdomains (wie `blog.beispiel.de` und `api.beispiel.de`). Dies ist eine entscheidende Ergänzung, erfordert aber, dass alle Subdomains vollständig über HTTPS erreichbar sind. Den ultimativen Schutz bietet die `preload`-Direktive. Wenn eine Website strenge Anforderungen erfüllt, kann sie in die <a href='https://hstspreload.org/' target='_blank' rel='noopener noreferrer' class='text-brand-secondary hover:underline'>'HSTS-Preload-Liste'</a> aufgenommen werden, eine Liste, die in großen Browsern wie Chrome, Firefox und Safari fest einprogrammiert ist. Das bedeutet, dass selbst die allererste Verbindung eines Benutzers zur Website sofort auf HTTPS gezwungen wird, wodurch kein Fenster für eine Schwachstelle mehr offen bleibt."
          ]
        },
        "csp": {
          "content": [
            "Die <a href='https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP' target='_blank' rel='noopener noreferrer' class='text-brand-secondary hover:underline'>Content-Security-Policy (CSP)</a> ist einer der leistungsstärksten und wesentlichsten Verteidigungsmechanismen gegen eine breite Palette von Content-Injection-Angriffen, mit dem Hauptziel, <a href='https://owasp.org/www-community/attacks/xss/' target='_blank' rel='noopener noreferrer' class='text-brand-secondary hover:underline'>Cross-Site Scripting (XSS)</a> zu entschärfen. Kurz gesagt, ermöglicht CSP einem Website-Administrator, eine strikte 'Whitelist' vertrauenswürdiger Quellen zu definieren. Nur Inhalte, die von diesen explizit genehmigten Domains stammen, dürfen vom Browser geladen und ausgeführt werden. Dies umfasst Skripte, Stylesheets, Bilder, Schriftarten, Iframes und mehr. Alles, was nicht auf dieser Liste steht, wird vom Browser gnadenlos blockiert, wodurch die Angriffsfläche für häufige Schwachstellen drastisch verkleinert wird.",
            "Um die Macht der CSP zu verstehen, muss man zuerst die Bedrohung durch XSS verstehen. Ein XSS-Angriff findet statt, wenn es einem Angreifer gelingt, bösartigen Code, meist JavaScript, in eine legitime Website einzuschleusen. Dies kann über ein Kommentarfeld, eine Suchleiste oder eine manipulierte URL geschehen. Wenn ein anderer Benutzer die infizierte Seite besucht, wird dieses Skript in seinem Browser mit denselben Berechtigungen wie die Website selbst ausgeführt. Der Angreifer kann damit Sitzungs-Cookies stehlen, Tastatureingaben erfassen, die Seite visuell verändern oder den Benutzer auf eine Phishing-Seite umleiten. CSP packt dieses Problem an der Wurzel. Selbst wenn ein Angreifer ein bösartiges Skript einschleust, wird eine gut konfigurierte CSP den Browser anweisen, dieses Skript nicht auszuführen, da es nicht von einer genehmigten Quelle stammt. Standardmäßig blockiert CSP auch Inline-Skripte und `eval()`-ähnliche Funktionen, die gängige Techniken bei XSS-Angriffen sind.",
            "Die Konfiguration einer CSP erfolgt über eine Reihe von 'Direktiven' im Header-Wert. Jede Direktive verwaltet einen bestimmten Inhaltstyp. So bestimmt `script-src`, welche Quellen Skripte liefern dürfen, `style-src` regelt Stylesheets und `img-src` verwaltet Bilder. Die `default-src`-Direktive fungiert als Fallback für die meisten anderen Direktiven. Häufig verwendete Quellwerte sind `'self'` (was sich auf die eigene Domain bezieht), spezifische Domains (wie `https://apis.google.com`) und `'none'` (was nichts erlaubt). Die Implementierung einer CSP erfordert eine sorgfältige Planung, da eine zu strenge Richtlinie die legitime Funktionalität beeinträchtigen kann. Daher bietet CSP auch einen `report-only`-Modus. In diesem Modus werden Verstöße nicht blockiert, sondern es wird ein Bericht an eine vom Entwickler angegebene URL über die `report-uri`- oder `report-to`-Direktive gesendet. Dies ermöglicht es Teams, ihre Richtlinie in einer Produktionsumgebung zu testen und zu verfeinern, ohne die Benutzererfahrung zu stören."
          ]
        },
        "xcto": {
          "content": [
            "Der <a href='https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Content-Type-Options' target='_blank' rel='noopener noreferrer' class='text-brand-secondary hover:underline'>`X-Content-Type-Options`</a>-Header ist eine scheinbar einfache, aber äußerst effektive Sicherheitsmaßnahme, die einen spezifischen und heimtückischen Angriffsvektor blockiert: MIME-Type-Sniffing. Mit nur einem möglichen, gültigen Wert, `nosniff`, gibt dieser Header dem Browser eine klare und unmissverständliche Anweisung: Vertraue dem vom Server gesendeten `Content-Type`-Header und versuche unter keinen Umständen, selbst zu erraten, um welchen Dateityp es sich handelt. Diese einfache Regel ist eine grundlegende Verteidigung gegen eine Klasse von Angriffen, die die Neigung von Browsern ausnutzen, 'hilfsbereit' zu sein.",
            "Der Kern des Problems ist das <a href='https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types#mime_sniffing' target='_blank' rel='noopener noreferrer' class='text-brand-secondary hover:underline'>'MIME-Sniffing'</a>. Webserver senden mit jeder Datei einen `Content-Type`-Header, um dem Browser mitzuteilen, was es ist (z. B. `text/html`, `image/jpeg`, `application/javascript`). Ältere Browser versuchten jedoch manchmal, schlauer als der Server zu sein. Wenn ein Server beispielsweise eine Datei mit `Content-Type: text/plain` sendete, der Inhalt aber wie HTML aussah, konnte der Browser entscheiden, sie trotzdem als HTML zu rendern. Obwohl dies dazu gedacht war, falsch konfigurierte Server zu korrigieren, schuf es eine gefährliche Schwachstelle. Ein Angreifer kann dies ausnutzen, indem er eine Datei hochlädt, die auf den ersten Blick harmlos erscheint, aber tatsächlich bösartigen Code enthält.",
            "Ein klassisches Angriffsszenario sieht wie folgt aus: Ein Angreifer lädt eine Datei auf eine Website hoch, zum Beispiel als Profilbild. Diese Datei hat die Erweiterung `.jpg` und enthält gültige Bilddaten, aber es ist auch bösartiger JavaScript-Code darin versteckt. Der Server sieht die `.jpg`-Erweiterung, vertraut ihr und liefert die Datei mit `Content-Type: image/jpeg`. Wenn ein Opfer dieses 'Bild' betrachtet, könnte ein Browser ohne die `nosniff`-Anweisung die Datei inspizieren. Der Browser erkennt den JavaScript-Code und entscheidet, trotz des `Content-Type`-Headers, dass es sich um ein Skript handelt und führt es aus. Da dieses Skript im Kontext der Website ausgeführt wird, hat es Zugriff auf die Sitzung des Benutzers, was zu einer vollständigen Übernahme des Kontos durch Cross-Site Scripting (XSS) führen kann.",
            "Der `X-Content-Type-Options: nosniff`-Header stoppt diesen Angriff vollständig. Der Browser erhält nun den expliziten Befehl: 'Wenn der Server sagt, dass dies ein `image/jpeg` ist, behandle es als Bild und nichts anderes.' Der Browser wird nicht mehr versuchen, den Inhalt zu 'sniffen' und den versteckten JavaScript-Code ignorieren. Die Implementierung ist trivial – es ist einfach das Hinzufügen eines einzigen Headers zu allen Serverantworten. Es ist ein perfektes Beispiel für ein 'Defense-in-Depth'-Prinzip: Selbst wenn andere Sicherheitsebenen (wie die Dateivalidierung beim Hochladen) versagen, bietet dieser Header eine robuste letzte Verteidigungslinie. Es ist eine wesentliche, unkomplizierte Maßnahme, die auf jeder modernen Website vorhanden sein sollte."
          ]
        },
        "xfo": {
          "content": [
            "Der <a href='https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Frame-Options' target='_blank' rel='noopener noreferrer' class='text-brand-secondary hover:underline'>`X-Frame-Options`</a>-Header ist eine entscheidende Sicherheitsmaßnahme, die speziell entwickelt wurde, um einen heimtückischen Angriff namens <a href='https://owasp.org/www-community/attacks/Clickjacking' target='_blank' rel='noopener noreferrer' class='text-brand-secondary hover:underline'>'Clickjacking'</a> zu verhindern. Clickjacking, auch bekannt als 'UI-Redress-Attack', ist eine Technik, bei der ein Angreifer einen Benutzer dazu verleitet, auf etwas anderes zu klicken, als der Benutzer wahrnimmt. Dies wird normalerweise erreicht, indem eine unsichtbare oder transparente Webseite (oder ein Teil davon) in einem Iframe über die sichtbare Seite gelegt wird. Der Benutzer denkt, er klickt auf einen harmlosen Knopf wie 'Preis gewinnen', aber in Wirklichkeit wird sein Klick auf der unsichtbaren Seite darunter registriert, zum Beispiel auf einem 'Mein Konto löschen'-Knopf einer Website, auf der er gerade angemeldet ist.",
            "Der `X-Frame-Options`-Header bietet eine einfache, aber effektive Möglichkeit zu steuern, ob ein Browser eine Seite in Einbettungselementen wie Frames oder Iframes rendern darf. Durch das Einfügen dieses Headers in die HTTP-Antwort einer Webseite kann der Server den Browser anweisen, wie solche Anfragen zu behandeln sind. Es gibt zwei gebräuchliche und eine veraltete Direktive. Die restriktivste und sicherste Option ist `DENY`. Dieser Wert verbietet das Rendern der Seite in einem Frame vollständig, unabhängig davon, welche Website dies versucht. Dies ist die beste Wahl für Seiten mit sehr sensiblen Aktionen, die niemals eingebettet werden sollten, wie Seiten zum Ändern von Passwörtern oder zur Durchführung von Finanztransaktionen.",
            "Eine flexiblere und sehr gebräuchliche Option ist `SAMEORIGIN`. Diese Direktive erlaubt das Rendern der Seite in einem Frame, aber nur, wenn die Website, die versucht, die Seite einzubetten, denselben Ursprung (Domain) hat wie die Seite selbst. Dies ist besonders nützlich für Webanwendungen, die Iframes für ihre eigene legitime Funktionalität verwenden, wie das Anzeigen von modalen Fenstern oder die Integration verschiedener Teile derselben Anwendung, während das Einbetten durch externe, potenziell bösartige Websites verhindert wird. Eine dritte, veraltete Option ist `ALLOW-FROM uri`, mit der eine bestimmte URL angegeben werden konnte, die die Seite framen durfte. Diese Option wurde jedoch nie von allen Browsern weitgehend unterstützt und gilt heute als veraltet.",
            "Obwohl `X-Frame-Options` immer noch sehr relevant und effektiv ist, ist es wichtig zu beachten, dass die modernere `Content-Security-Policy` (CSP) eine <a href='https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/frame-ancestors' target='_blank' rel='noopener noreferrer' class='text-brand-secondary hover:underline'>`frame-ancestors`</a>-Direktive enthält. Diese Direktive gilt als Nachfolger von `X-Frame-Options`, da sie mehr Flexibilität bietet (wie die Angabe mehrerer erlaubter Domains). Aufgrund der breiten Unterstützung und Einfachheit bleibt die Implementierung von `X-Frame-Options` jedoch eine empfohlene 'Defense-in-Depth'-Strategie, insbesondere um die Kompatibilität mit älteren Browsern zu gewährleisten. Durch die korrekte Konfiguration dieses Headers wird eine ganze Klasse von UI-basierten Angriffen effektiv neutralisiert."
          ]
        },
        "rp": {
          "content": [
            "Der <a href='https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Referrer-Policy' target='_blank' rel='noopener noreferrer' class='text-brand-secondary hover:underline'>`Referrer-Policy`</a>-Header ist ein wesentliches Instrument zum Schutz der Privatsphäre der Benutzer, indem er steuert, welche Informationen im `Referer`-Header (beachten Sie den historischen Tippfehler) gesendet werden, wenn ein Benutzer von einer Seite zur anderen navigiert. Standardmäßig sendet ein Browser die vollständige URL der vorherigen Seite an die neue Seite. Obwohl dies für Analysen und das Verständnis von Verkehrsflüssen nützlich ist, birgt es ein erhebliches Datenschutzrisiko. URLs können sensible Informationen enthalten, wie Suchbegriffe, Benutzer-IDs oder sogar Token zum Zurücksetzen von Passwörtern. Die Weitergabe dieser Daten an Dritte ohne Wissen des Benutzers ist ein Datenleck, das ausgenutzt werden kann.",
            "Die `Referrer-Policy` gibt Website-Besitzern die Möglichkeit, dieses Verhalten mithilfe verschiedener Direktiven genau zu steuern. Die Wahl einer Direktive ist ein Kompromiss zwischen Datenschutz und Funktionalität. Eine der strengsten Optionen ist `no-referrer`. Wie der Name schon sagt, wird der `Referer`-Header in diesem Fall bei allen ausgehenden Anfragen vollständig weggelassen. Dies bietet maximale Privatsphäre, macht es aber für die empfangende Website unmöglich zu sehen, woher der Verkehr kommt, was die Analyse von Verkehrsquellen erschweren kann. Eine weitere gebräuchliche, datenschutzfreundliche Option ist `strict-origin-when-cross-origin`. Dies ist oft eine gute Standardwahl. Sie verhält sich wie folgt: Bei der Navigation innerhalb derselben Website (z. B. von `beispiel.de/seite1` zu `beispiel.de/seite2`) wird die vollständige URL gesendet. Bei der Navigation zu einer anderen Website (cross-origin) wird jedoch nur die Basis-URL (der Ursprung, z. B. `https://beispiel.de/`) gesendet, und nur, wenn die Verbindung gleich sicher ist (HTTPS zu HTTPS).",
            "Andere Direktiven bieten eine granularere Kontrolle. `same-origin` stellt sicher, dass der Referrer nur für Anfragen innerhalb derselben Website gesendet wird; bei allen anderen Anfragen wird er weggelassen. `strict-origin` sendet nur die Basis-URL, tut dies aber im Gegensatz zu `strict-origin-when-cross-origin` auch bei der Navigation innerhalb derselben Website. Am anderen Ende des Spektrums steht `unsafe-url`, was, wie der Name schon sagt, unsicher ist. Diese Direktive sendet immer die vollständige URL, einschließlich Abfrageparametern, auch bei unsicheren (HTTP) Anfragen. Ihre Verwendung wird dringend abgeraten. Durch die bewusste Wahl einer `Referrer-Policy` übernehmen Website-Besitzer die Verantwortung für die Daten ihrer Benutzer. Die Implementierung einer restriktiven Richtlinie wie `strict-origin-when-cross-origin` ist ein einfacher Schritt, der die Privatsphäre erheblich verbessert, ohne die wesentliche Funktionalität zu beeinträchtigen."
          ]
        },
        "pp": {
          "content": [
            "Der <a href='https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Permissions-Policy' target='_blank' rel='noopener noreferrer' class='text-brand-secondary hover:underline'>`Permissions-Policy`</a>-Header ist eine moderne und leistungsstarke Sicherheitsfunktion, die Website-Administratoren eine detaillierte Kontrolle darüber gibt, welche Browser-Funktionen und APIs auf einer Seite verwendet werden dürfen. Dieser Header, der die ältere `Feature-Policy` ersetzt, basiert auf dem 'Prinzip der geringsten Rechte': Ein Stück Code sollte nur die Rechte haben, die absolut notwendig sind, um seine Aufgabe zu erfüllen. Durch die explizite Definition, welche Funktionen erlaubt sind, können Entwickler die 'Angriffsfläche' ihrer Website erheblich verkleinern und die Privatsphäre der Benutzer besser schützen.",
            "Moderne Webanwendungen nutzen zunehmend leistungsstarke Browser-APIs wie den Zugriff auf die Kamera (`camera`), das Mikrofon (`microphone`), die Geolokalisierung (`geolocation`), den Vollbildmodus (`fullscreen`) und die Zahlungsabwicklung (`payment`). Obwohl diese Funktionen innovative Benutzererlebnisse ermöglichen, stellen sie auch ein potenzielles Risiko dar. Eine Schwachstelle in einem Drittanbieter-Skript, wie einem Werbe- oder Analyse-Skript, das auf Ihrer Seite geladen wird, könnte ausgenutzt werden, um unerwünschten Zugriff auf diese sensiblen APIs zu erhalten. Ein Benutzer könnte beispielsweise unwissentlich aufgefordert werden, einem nicht vertrauenswürdigen Skript, das sich auf Ihrer legitimen Website eingenistet hat, den Mikrofonzugriff zu gewähren.",
            "Die `Permissions-Policy` geht dieses Problem an, indem sie eine klare Richtlinie festlegt. Der Header besteht aus einer Reihe von Direktiven, wobei jede Direktive eine bestimmte Funktion darstellt. Für jede Funktion kann eine Liste von erlaubten 'Origins' (Domains) angegeben werden. Wenn eine Website beispielsweise keinen Zugriff auf das Mikrofon benötigt, kann der Entwickler dies explizit mit `permissions-policy: microphone=()` deaktivieren. Die leeren Klammern `()` bedeuten, dass die Funktion für alle Parteien (einschließlich der eigenen Website und aller Iframes) deaktiviert ist. Wenn eine Funktion nur von der eigenen Website verwendet werden soll, kann dies mit `microphone=('self')` eingestellt werden. Dies stellt sicher, dass eingebettete Iframes von Drittanbietern, wie ein YouTube-Video, keinen Zugriff auf das Mikrofon anfordern können.",
            "Die wahre Stärke der `Permissions-Policy` liegt in ihrer granularen Kontrolle über Inhalte von Drittanbietern. Sie können einer bestimmten Domain die Erlaubnis erteilen, zum Beispiel `permissions-policy: camera=('self' https://trusted-partner.com)`. Dies stellt sicher, dass nur Ihre eigene Website und ein vertrauenswürdiger Partner die Kamera verwenden dürfen. Alle anderen Iframes werden blockiert. Die Implementierung einer strengen `Permissions-Policy` ist eine bewährte Vorgehensweise für die moderne Webentwicklung. Sie zwingt Entwickler, bewusst darüber nachzudenken, welche Funktionalität ihre Anwendung wirklich benötigt, und bietet eine robuste Verteidigungsschicht gegen den Missbrauch von Browser-APIs. Dies führt zu einer sichereren Erfahrung für den Benutzer und stärkt das Vertrauen in Ihre Plattform."
          ]
        },
        "xxp": {
          "content": [
            "Der <a href='https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-XSS-Protection' target='_blank' rel='noopener noreferrer' class='text-brand-secondary hover:underline'>`X-XSS-Protection`</a>-Header ist ein Stück Internetgeschichte; eine Sicherheitsmaßnahme, die einst in Browsern wie Internet Explorer, Chrome und Safari als erste Verteidigungslinie gegen 'reflektierte' Cross-Site Scripting (XSS)-Angriffe eingeführt wurde. Obwohl die Absicht gut war, ist der Header inzwischen veraltet und wird von allen modernen Browsern missbilligt und sogar ignoriert. Seine Funktionalität wurde vollständig durch die viel robustere und konfigurierbarere `Content-Security-Policy` (CSP) ersetzt. Das Verständnis der Funktionsweise und der Mängel von `X-XSS-Protection` bietet jedoch wertvolle Einblicke in die Entwicklung der Websicherheit.",
            "Der Header wurde entwickelt, um einen bestimmten Angriffsvektor zu blockieren: einen <a href='https://owasp.org/www-community/attacks/xss/#reflected-xss-attacks' target='_blank' rel='noopener noreferrer' class='text-brand-secondary hover:underline'>'reflektierten' XSS-Angriff</a>. Diese Art von Angriff tritt auf, wenn bösartiger Code über einen URL-Parameter oder eine Formulareingabe vom Server 'reflektiert' und direkt in die HTML-Antwort eingefügt wird. Der `X-XSS-Protection`-Header aktivierte einen eingebauten 'Auditor' oder 'Filter' im Browser. Dieser Filter verwendete Heuristiken, um zu erkennen, ob Skriptcode in der Anfrage (z. B. in der URL) auch buchstäblich im HTML der Seite erschien. Wenn dies der Fall war, schloss der Browser, dass ein Angriff stattfand.",
            "Der Header konnte verschiedene Werte haben. Der Standardwert war `1`, was den Filter aktivierte. Bei Erkennung eines Angriffs versuchte der Browser, die Seite zu 'sanieren', indem er den bösartigen Code entfernte oder neutralisierte. Dies erwies sich jedoch als gefährlicher Ansatz. Angreifer entdeckten Wege, diese Sanierungsmechanismen zu umgehen und konnten in einigen Fällen sogar Schwachstellen schaffen, die ohne den Filter nicht existierten. Eine sicherere Option war `1; mode=block`. In diesem Modus würde der Browser bei Erkennung eines Angriffs das Rendern der Seite vollständig stoppen und eine leere Seite anzeigen. Dies verhinderte die Ausführung des Skripts, bot aber eine schlechte Benutzererfahrung. Der Wert `0` deaktivierte den Filter explizit.",
            "Letztendlich wurde der Header aus mehreren Gründen abgeschafft. Die Filter waren unzuverlässig, konnten umgangen werden und verursachten manchmal 'False Positives', die legitime Websites beschädigten. Wichtiger noch, der Aufstieg der `Content-Security-Policy` bot einen grundlegend überlegenen Ansatz. Anstatt zu versuchen, Angriffe auf der Grundlage unzuverlässiger Heuristiken zu 'erraten', ermöglicht CSP den Entwicklern, eine strikte 'Whitelist' vertrauenswürdiger Codequellen zu definieren. Dieses 'Deny by Default'-Modell ist von Natur aus sicherer. Obwohl Sie den `X-XSS-Protection`-Header immer noch auf älteren Websites finden können, ist er für die moderne Webentwicklung keine aktive Sicherheitsmaßnahme mehr. Der Fokus liegt jetzt vollständig auf einer starken und gut konfigurierten CSP."
          ]
        }
      }
    }
  },
  fr: {
    "meta": {
      "title": "Analyse des En-têtes de Sécurité | Scan de Sécurité Gratuit pour Site Web",
      "description": "Vérifiez les en-têtes de sécurité HTTP de votre site web avec notre outil gratuit. Analysez CSP, HSTS, et plus pour trouver des vulnérabilités et sécuriser votre site."
    },
    "header": {
      "title": "Analyse des En-têtes de Sécurité",
      "subtitle": "Vérifiez la sécurité de n'importe quel site web"
    },
    "form": {
      "label": "URL du site web",
      "placeholder": "www.exemple.fr",
      "button": {
        "analyze": "Analyser",
        "analyzing": "Analyse en cours..."
      }
    },
    "results": {
      "title": "Résultats pour",
      "value": {
        "notPresent": "Non présent"
      },
      "button": {
        "explanation": "Explication"
      }
    },
    "errors": {
      "unknown": "Une erreur inconnue est survenue.",
      "analysisFailed": "L'analyse a échoué. Assurez-vous que l'URL est correcte. Erreur : {{errorMessage}}"
    },
    "seo": {
      "title": "Pourquoi les En-têtes de Sécurité sont-ils Importants ?",
      "intro": "Les en-têtes de sécurité HTTP sont un élément fondamental de la sécurité des sites web. Ils permettent aux serveurs web d'indiquer aux navigateurs comment se comporter lors du traitement du contenu d'un site. Cela aide à prévenir les attaques courantes telles que le Cross-Site Scripting (XSS), le clickjacking et les attaques de l'homme du milieu. En implémentant correctement des en-têtes comme <strong>Content-Security-Policy</strong>, <strong>Strict-Transport-Security</strong> et <strong>X-Frame-Options</strong>, vous ajoutez une couche de défense cruciale à votre application. Cela protège non seulement votre site web, mais aussi les données et la vie privée de vos utilisateurs.",
      "howItWorks": {
        "title": "Comment fonctionne cet Outil ?",
        "body": "Cet outil analyse l'URL que vous saisissez et vérifie la présence et la configuration correcte des en-têtes de sécurité les plus importants. Nous fournissons un aperçu clair des en-têtes présents et de ceux qui sont absents. De plus, nous offrons une explication détaillée de l'objectif de chaque en-tête et des risques que vous encourez s'il n'est pas présent. Utilisez cette analyse pour améliorer la sécurité de votre site web."
      },
      "accordion": {
        "hsts": {
          "content": [
            "L'en-tête <a href='https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Strict-Transport-Security' target='_blank' rel='noopener noreferrer' class='text-brand-secondary hover:underline'>HTTP Strict Transport Security (HSTS)</a> est une mesure de sécurité puissante qui protège les sites web contre les <a href='https://owasp.org/www-community/attacks/Man-in-the-middle_attack' target='_blank' rel='noopener noreferrer' class='text-brand-secondary hover:underline'>attaques de l'homme du milieu</a>, telles que les attaques par rétrogradation de protocole et le détournement de cookies. Essentiellement, c'est une instruction du serveur web au navigateur de communiquer exclusively via une connexion HTTPS sécurisée et chiffrée, et jamais via le protocole non sécurisé HTTP. Cette instruction est mémorisée par le navigateur pour une période spécifiée par le site web.",
            "Le principal danger auquel HSTS s'attaque est le 'SSL stripping'. Imaginez un utilisateur se connectant à un réseau Wi-Fi public dans un café. Un attaquant sur le même réseau peut intercepter la première requête HTTP non sécurisée de l'utilisateur. Même si le site web redirige normalement vers HTTPS, l'attaquant peut bloquer cette redirection et maintenir une connexion non chiffrée avec l'utilisateur, tout en établissant lui-même une connexion chiffrée avec le serveur. L'utilisateur ne remarque rien, mais l'attaquant peut maintenant lire tout le trafic, y compris les mots de passe et les données personnelles, en clair. HSTS empêche complètement ce scénario. Une fois qu'un navigateur a reçu l'en-tête HSTS d'un domaine, il convertira automatiquement et en interne toutes les futures tentatives de connexion via HTTP en HTTPS, avant même que la requête ne quitte le réseau. L'attaquant n'a tout simplement jamais l'occasion d'intercepter la connexion.",
            "L'implémentation de HSTS se fait via l'en-tête lui-même, qui peut contenir plusieurs directives. La plus importante est `max-age`, qui spécifie en secondes la durée pendant laquelle le navigateur doit mémoriser la règle HSTS. Une valeur recommandée typique est 31536000, ce qui correspond à un an. Une autre directive puissante est `includeSubDomains`. Si elle est présente, la règle HSTS s'applique non seulement au domaine principal (par exemple, `www.exemple.fr`), mais aussi à tous les sous-domaines (tels que `blog.exemple.fr` et `api.exemple.fr`). C'est un ajout crucial, mais il nécessite que tous les sous-domaines soient entièrement accessibles via HTTPS. La protection ultime est fournie par la directive `preload`. Si un site web remplit des conditions strictes, il peut être inclus dans la <a href='https://hstspreload.org/' target='_blank' rel='noopener noreferrer' class='text-brand-secondary hover:underline'>'liste de préchargement HSTS'</a>, une liste codée en dur dans les principaux navigateurs comme Chrome, Firefox et Safari. Cela signifie que même la toute première connexion d'un utilisateur au site web est immédiatement forcée en HTTPS, ne laissant aucune fenêtre de vulnérabilité."
          ]
        },
        "csp": {
          "content": [
            "La <a href='https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP' target='_blank' rel='noopener noreferrer' class='text-brand-secondary hover:underline'>Content-Security-Policy (CSP)</a> est l'un des mécanismes de défense les plus puissants et essentiels contre un large éventail d'attaques par injection de contenu, avec pour objectif principal d'atténuer le <a href='https://owasp.org/www-community/attacks/xss/' target='_blank' rel='noopener noreferrer' class='text-brand-secondary hover:underline'>Cross-Site Scripting (XSS)</a>. En un mot, la CSP permet à un administrateur de site web de définir une 'liste blanche' stricte de sources fiables. Seul le contenu provenant de ces domaines explicitement approuvés peut être chargé et exécuté par le navigateur. Cela inclut les scripts, les feuilles de style, les images, les polices, les iframes, etc. Tout ce qui n'est pas sur cette liste est impitoyablement bloqué par le navigateur, réduisant ainsi considérablement la surface d'attaque pour les vulnérabilités courantes.",
            "Pour comprendre la puissance de la CSP, il faut d'abord comprendre la menace du XSS. Une attaque XSS se produit lorsqu'un attaquant parvient à injecter du code malveillant, généralement du JavaScript, dans un site web légitime. Cela peut se produire via un champ de commentaire, une barre de recherche ou une URL manipulée. Lorsqu'un autre utilisateur visite la page infectée, ce script est exécuté dans son navigateur avec les mêmes autorisations que le site web lui-même. L'attaquant peut l'utiliser pour voler des cookies de session, capturer des frappes au clavier, modifier visuellement la page ou rediriger l'utilisateur vers un site de phishing. La CSP s'attaque à ce problème à la racine. Même si un attaquant injecte un script malveillant, une CSP bien configurée demandera au navigateur de ne pas l'exécuter car il ne provient pas d'une source approuvée. Par défaut, la CSP bloque également les scripts en ligne et les fonctions de type `eval()`, qui sont des techniques courantes dans les attaques XSS.",
            "La configuration d'une CSP se fait par le biais d'une série de 'directives' dans la valeur de l'en-tête. Chaque directive gère un type de contenu spécifique. Par exemple, `script-src` détermine quelles sources peuvent fournir des scripts, `style-src` contrôle les feuilles de style et `img-src` gère les images. La directive `default-src` sert de solution de repli pour la plupart des autres directives. Les valeurs de source courantes sont `'self'` (qui fait référence au propre domaine), des domaines spécifiques (comme `https://apis.google.com`) et `'none'` (qui n'autorise rien). La mise en œuvre d'une CSP nécessite une planification minutieuse, car une politique trop stricte peut casser des fonctionnalités légitimes. C'est pourquoi la CSP propose également un mode `report-only`. Dans ce mode, les violations ne sont pas bloquées, mais un rapport est envoyé à une URL spécifiée par le développeur via la directive `report-uri` ou `report-to`. Cela permet aux équipes de tester et d'affiner leur politique dans un environnement de production sans perturber l'expérience utilisateur."
          ]
        },
        "xcto": {
          "content": [
            "L'en-tête <a href='https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Content-Type-Options' target='_blank' rel='noopener noreferrer' class='text-brand-secondary hover:underline'>`X-Content-Type-Options`</a> est une mesure de sécurité d'apparence simple, mais extrêmement efficace, qui bloque un vecteur d'attaque spécifique et insidieux : le reniflage de type MIME. Avec une seule valeur possible et valide, `nosniff`, cet en-tête donne une instruction claire et sans ambiguïté au navigateur : faites confiance à l'en-tête `Content-Type` envoyé par le serveur et n'essayez en aucun cas de deviner vous-même le type de fichier que vous recevez. Cette règle simple est une défense fondamentale contre une classe d'attaques qui exploitent la tendance des navigateurs à être 'serviables'.",
            "Le cœur du problème est le <a href='https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types#mime_sniffing' target='_blank' rel='noopener noreferrer' class='text-brand-secondary hover:underline'>'reniflage MIME'</a>. Les serveurs web envoient un en-tête `Content-Type` avec chaque fichier pour indiquer au navigateur ce que c'est (par ex., `text/html`, `image/jpeg`, `application/javascript`). Cependant, les anciens navigateurs essayaient parfois d'être plus malins que le serveur. Par exemple, si un serveur envoyait un fichier avec `Content-Type: text/plain`, mais que le contenu ressemblait à du HTML, le navigateur pouvait décider de le rendre quand même en HTML. Bien que cela ait été destiné à corriger les serveurs mal configurés, cela a créé une vulnérabilité dangereuse. Un attaquant peut en abuser en téléchargeant un fichier qui semble inoffensif à première vue mais qui contient en réalité du code malveillant.",
            "Un scénario d'attaque classique se présente comme suit : un attaquant télécharge un fichier sur un site web, par exemple comme photo de profil. Ce fichier a une extension `.jpg` et contient des données d'image valides, mais du code JavaScript malveillant y est également caché. Le serveur voit l'extension `.jpg`, lui fait confiance et sert le fichier avec `Content-Type: image/jpeg`. Lorsqu'une victime visualise cette 'image', un navigateur sans l'instruction `nosniff` pourrait inspecter le fichier. Le navigateur détecte le code JavaScript et décide, malgré l'en-tête `Content-Type`, qu'il s'agit d'un script et l'exécute. Comme ce script est exécuté dans le contexte du site web, il a accès à la session de l'utilisateur, ce qui peut entraîner une prise de contrôle complète du compte via le Cross-Site Scripting (XSS).",
            "L'en-tête `X-Content-Type-Options: nosniff` arrête complètement cette attaque. Le navigateur reçoit maintenant l'ordre explicite : 'Si le serveur dit que c'est une `image/jpeg`, traitez-le comme une image et rien d'autre.' Le navigateur n'essaiera plus de 'renifler' le contenu et ignorera le code JavaScript caché. La mise en œuvre est triviale – il s'agit simplement d'ajouter un seul en-tête à toutes les réponses du serveur. C'est un parfait exemple du principe de 'défense en profondeur' : même si d'autres couches de sécurité (comme la validation des fichiers lors du téléchargement) échouent, cet en-tête fournit une dernière ligne de défense robuste. C'est une mesure essentielle et peu coûteuse qui devrait être présente sur tout site web moderne."
          ]
        },
        "xfo": {
          "content": [
            "L'en-tête <a href='https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Frame-Options' target='_blank' rel='noopener noreferrer' class='text-brand-secondary hover:underline'>`X-Frame-Options`</a> est une mesure de sécurité cruciale spécifiquement conçue pour empêcher une attaque insidieuse appelée <a href='https://owasp.org/www-community/attacks/Clickjacking' target='_blank' rel='noopener noreferrer' class='text-brand-secondary hover:underline'>'clickjacking'</a>. Le clickjacking, également connu sous le nom d'attaque de 'réparation d'interface utilisateur', est une technique par laquelle un attaquant trompe un utilisateur pour qu'il clique sur quelque chose de différent de ce qu'il perçoit. Ceci est généralement réalisé en superposant une page web invisible ou transparente (ou une partie de celle-ci) dans un iframe sur la page visible. L'utilisateur pense qu'il clique sur un bouton inoffensif, comme 'Gagner un prix', mais en réalité, son clic est enregistré sur la page invisible en dessous, par exemple, sur un bouton 'Supprimer mon compte' d'un site web sur lequel il est actuellement connecté.",
            "L'en-tête `X-Frame-Options` offre un moyen simple mais efficace de contrôler si un navigateur est autorisé à afficher une page dans des éléments d'intégration tels que des cadres ou des iframes. En incluant cet en-tête dans la réponse HTTP d'une page web, le serveur peut indiquer au navigateur comment traiter de telles requêtes. Il existe deux directives couramment utilisées et une obsolète. L'option la plus restrictive et la plus sûre est `DENY`. Cette valeur interdit complètement l'affichage de la page dans un cadre, quel que soit le site web qui tente de le faire. C'est le meilleur choix pour les pages avec des actions très sensibles qui ne devraient jamais être intégrées, comme les pages de changement de mot de passe ou les pages de transactions financières.",
            "Une option plus flexible et très courante est `SAMEORIGIN`. Cette directive autorise l'affichage de la page dans un cadre, mais uniquement si le site web qui tente d'intégrer la page a la même origine (domaine) que la page elle-même. C'est particulièrement utile pour les applications web qui utilisent des iframes pour leurs propres fonctionnalités légitimes, comme l'affichage de fenêtres modales ou l'intégration de différentes parties de la même application, tout en empêchant l'intégration par des sites web externes potentiellement malveillants. Une troisième option, obsolète, est `ALLOW-FROM uri`, qui permettait de spécifier une URL spécifique autorisée à encadrer la page. Cependant, cette option n'a jamais été largement prise en charge par tous les navigateurs et est maintenant considérée comme obsolète.",
            "Bien que `X-Frame-Options` soit toujours très pertinent et efficace, il est important de noter que la `Content-Security-Policy` (CSP) plus moderne inclut une directive <a href='https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/frame-ancestors' target='_blank' rel='noopener noreferrer' class='text-brand-secondary hover:underline'>`frame-ancestors`</a>. Cette directive est considérée comme le successeur de `X-Frame-Options` car elle offre plus de flexibilité (comme la spécification de plusieurs domaines autorisés). Cependant, en raison de son large soutien et de sa simplicité, la mise en œuvre de `X-Frame-Options` reste une stratégie de 'défense en profondeur' recommandée, en particulier pour assurer la compatibilité avec les navigateurs plus anciens. En configurant correctement cet en-tête, toute une classe d'attaques basées sur l'interface utilisateur est efficacement neutralisée."
          ]
        },
        "rp": {
          "content": [
            "L'en-tête <a href='https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Referrer-Policy' target='_blank' rel='noopener noreferrer' class='text-brand-secondary hover:underline'>`Referrer-Policy`</a> est un instrument essentiel pour protéger la vie privée des utilisateurs en contrôlant les informations envoyées dans l'en-tête `Referer` (notez la faute d'orthographe historique) lorsqu'un utilisateur navigue d'une page à une autre. Par défaut, un navigateur envoie l'URL complète de la page précédente à la nouvelle page. Bien que cela soit utile pour l'analyse et la compréhension des flux de trafic, cela crée un risque de confidentialité important. Les URL peuvent contenir des informations sensibles, telles que des termes de recherche, des identifiants d'utilisateur ou même des jetons de réinitialisation de mot de passe. La transmission de ces données à des tiers à l'insu de l'utilisateur est une fuite de données qui peut être exploitée.",
            "La `Referrer-Policy` permet aux propriétaires de sites web de contrôler précisément ce comportement à l'aide de diverses directives. Le choix d'une directive est un compromis entre la confidentialité et la fonctionnalité. L'une des options les plus strictes est `no-referrer`. Comme son nom l'indique, l'en-tête `Referer` est complètement omis de toutes les requêtes sortantes dans ce cas. Cela offre une confidentialité maximale mais empêche le site récepteur de voir d'où vient le trafic, ce qui peut compliquer l'analyse des sources de trafic. Une autre option courante et respectueuse de la vie privée est `strict-origin-when-cross-origin`. C'est souvent un bon choix par défaut. Il se comporte comme suit : pour la navigation au sein du même site web (par exemple, de `exemple.fr/page1` à `exemple.fr/page2`), l'URL complète est envoyée. Cependant, pour la navigation vers un autre site web (cross-origin), seule l'URL de base (l'origine, par exemple, `https://exemple.fr/`) est envoyée, et uniquement si la connexion est également sécurisée (HTTPS vers HTTPS).",
            "D'autres directives offrent un contrôle plus granulaire. `same-origin` garantit que le référent n'est envoyé que pour les requêtes au sein du même site web ; il est omis pour toutes les autres requêtes. `strict-origin` envoie uniquement l'URL de base, mais contrairement à `strict-origin-when-cross-origin`, il le fait également pour la navigation au sein du même site. À l'autre extrémité du spectre se trouve `unsafe-url`, qui, comme son nom l'indique, n'est pas sûr. Cette directive envoie toujours l'URL complète, y compris les paramètres de requête, même sur des requêtes non sécurisées (HTTP). Son utilisation est fortement déconseillée. En choisissant consciemment une `Referrer-Policy`, les propriétaires de sites web assument la responsabilité des données de leurs utilisateurs. La mise en œuvre d'une politique restrictive, telle que `strict-origin-when-cross-origin`, est une étape simple qui améliore considérablement la confidentialité sans casser les fonctionnalités essentielles."
          ]
        },
        "pp": {
          "content": [
            "L'en-tête <a href='https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Permissions-Policy' target='_blank' rel='noopener noreferrer' class='text-brand-secondary hover:underline'>`Permissions-Policy`</a> est une fonctionnalité de sécurité moderne et puissante qui donne aux administrateurs de sites web un contrôle détaillé sur les fonctionnalités et les API du navigateur qui peuvent être utilisées sur une page. Cet en-tête, qui remplace l'ancien `Feature-Policy`, est basé sur le 'principe du moindre privilège' : un morceau de code ne devrait avoir que les autorisations absolument nécessaires pour effectuer sa tâche. En définissant explicitement les fonctionnalités autorisées, les développeurs peuvent réduire considérablement la 'surface d'attaque' de leur site web et mieux protéger la vie privée des utilisateurs.",
            "Les applications web modernes utilisent de plus en plus de puissantes API de navigateur, telles que l'accès à la caméra (`camera`), au microphone (`microphone`), à la géolocalisation (`geolocation`), au mode plein écran (`fullscreen`) et au traitement des paiements (`payment`). Bien que ces fonctionnalités permettent des expériences utilisateur innovantes, elles présentent également un risque potentiel. Une vulnérabilité dans un script tiers, tel qu'un script de publicité ou d'analyse chargé sur votre page, pourrait être exploitée pour obtenir un accès non désiré à ces API sensibles. Par exemple, un utilisateur pourrait être invité à son insu à accorder l'accès au microphone à un script non fiable se greffant sur votre site web légitime.",
            "La `Permissions-Policy` résout ce problème en spécifiant une politique claire. L'en-tête se compose d'une série de directives, où chaque directive représente une fonctionnalité spécifique. Pour chaque fonctionnalité, une liste d''origines' (domaines) autorisées peut être spécifiée. Par exemple, si un site web n'a pas besoin d'accéder au microphone, le développeur peut le désactiver explicitement avec `permissions-policy: microphone=()`. Les parenthèses vides `()` signifient que la fonctionnalité est désactivée pour toutes les parties (y compris le site propre et tous les iframes). Si une fonctionnalité ne doit être utilisée que par le site web propre, elle peut être définie avec `microphone=('self')`. Cela garantit que les iframes intégrés de tiers, comme une vidéo YouTube, ne peuvent pas demander l'accès au microphone.",
            "La véritable puissance de `Permissions-Policy` réside dans son contrôle granulaire sur le contenu de tiers. Vous pouvez accorder une autorisation à un domaine spécifique, par exemple `permissions-policy: camera=('self' https://trusted-partner.com)`. Cela garantit que seul votre propre site et un partenaire de confiance peuvent utiliser la caméra. Tous les autres iframes seront bloqués. La mise en œuvre d'une `Permissions-Policy` stricte est une meilleure pratique pour le développement web moderne. Elle oblige les développeurs à réfléchir consciemment aux fonctionnalités dont leur application a réellement besoin et fournit une couche de défense robuste contre l'abus des API du navigateur. Cela se traduit par une expérience plus sûre pour l'utilisateur et renforce la confiance dans votre plateforme."
          ]
        },
        "xxp": {
          "content": [
            "L'en-tête <a href='https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-XSS-Protection' target='_blank' rel='noopener noreferrer' class='text-brand-secondary hover:underline'>`X-XSS-Protection`</a> est un morceau de l'histoire d'Internet ; une mesure de sécurité autrefois introduite dans les navigateurs comme Internet Explorer, Chrome et Safari comme première ligne de défense contre les attaques de Cross-Site Scripting (XSS) 'réfléchies'. Bien que l'intention soit bonne, l'en-tête est maintenant obsolète et est déprécié et même ignoré par tous les navigateurs modernes. Sa fonctionnalité a été entièrement remplacée par la `Content-Security-Policy` (CSP), beaucoup plus robuste et configurable. Cependant, la compréhension du fonctionnement et des lacunes de `X-XSS-Protection` offre un aperçu précieux de l'évolution de la sécurité web.",
            "L'en-tête a été conçu pour bloquer un vecteur d'attaque spécifique : une <a href='https://owasp.org/www-community/attacks/xss/#reflected-xss-attacks' target='_blank' rel='noopener noreferrer' class='text-brand-secondary hover:underline'>attaque XSS 'réfléchie'</a>. Ce type d'attaque se produit lorsque du code malveillant, via un paramètre d'URL ou une entrée de formulaire, est 'réfléchi' par le serveur et inclus directement dans la réponse HTML. L'en-tête `X-XSS-Protection` activait un 'auditeur' ou 'filtre' intégré dans le navigateur. Ce filtre utilisait des heuristiques pour détecter si le code de script dans la requête (par exemple, dans l'URL) apparaissait également littéralement dans le HTML de la page. Si c'était le cas, le navigateur concluait qu'une attaque avait lieu.",
            "L'en-tête pouvait avoir plusieurs valeurs. La valeur par défaut était `1`, ce qui activait le filtre. Lors de la détection d'une attaque, le navigateur tentait de 'nettoyer' la page en supprimant ou en neutralisant le code malveillant. Cependant, cette approche s'est avérée dangereuse. Les attaquants ont découvert des moyens de contourner ces mécanismes de nettoyage et, dans certains cas, ont même pu créer des vulnérabilités qui n'existaient pas sans le filtre. Une option plus sûre était `1; mode=block`. Dans ce mode, lors de la détection d'une attaque, le navigateur arrêtait complètement le rendu de la page et affichait une page blanche. Cela empêchait l'exécution du script mais offrait une mauvaise expérience utilisateur. La valeur `0` désactivait explicitement le filtre.",
            "Finalement, l'en-tête a été déprécié pour plusieurs raisons. Les filtres n'étaient pas fiables, pouvaient être contournés et provoquaient parfois des 'faux positifs' qui cassaient des sites web légitimes. Plus important encore, l'essor de la `Content-Security-Policy` offrait une approche fondamentalement supérieure. Au lieu d'essayer de 'deviner' les attaques sur la base d'heuristiques peu fiables, la CSP permet aux développeurs de définir une 'liste blanche' stricte de sources de code fiables. Ce modèle de 'refus par défaut' est intrinsèquement plus sûr. Bien que vous puissiez encore rencontrer l'en-tête `X-XSS-Protection` sur des sites web plus anciens, il n'est plus considéré comme une mesure de sécurité active pour le développement web moderne. L'accent est désormais entièrement mis sur une CSP forte et bien configurée."
          ]
        }
      }
    }
  },
  es: {
    "meta": {
      "title": "Análisis de Cabeceras de Seguridad | Escaneo de Seguridad Gratuito para Sitios Web",
      "description": "Compruebe las cabeceras de seguridad HTTP de su sitio web con nuestra herramienta gratuita. Analice CSP, HSTS y más para encontrar vulnerabilidades y proteger su sitio."
    },
    "header": {
      "title": "Análisis de Cabeceras de Seguridad",
      "subtitle": "Compruebe la seguridad de cualquier sitio web"
    },
    "form": {
      "label": "URL del sitio web",
      "placeholder": "www.ejemplo.es",
      "button": {
        "analyze": "Analizar",
        "analyzing": "Analizando..."
      }
    },
    "results": {
      "title": "Resultados para",
      "value": {
        "notPresent": "No presente"
      },
      "button": {
        "explanation": "Explicación"
      }
    },
    "errors": {
      "unknown": "Se ha producido un error desconocido.",
      "analysisFailed": "El análisis ha fallado. Asegúrese de que la URL es correcta. Error: {{errorMessage}}"
    },
    "seo": {
      "title": "¿Por qué son Importantes las Cabeceras de Seguridad?",
      "intro": "Las cabeceras de seguridad HTTP son una parte fundamental de la seguridad de un sitio web. Permiten a los servidores web dar instrucciones a los navegadores sobre cómo deben comportarse al procesar el contenido de un sitio. Esto ayuda a prevenir ataques comunes como el Cross-Site Scripting (XSS), el clickjacking y los ataques de intermediario (man-in-the-middle). Al implementar correctamente cabeceras como <strong>Content-Security-Policy</strong>, <strong>Strict-Transport-Security</strong> y <strong>X-Frame-Options</strong>, añade una capa de defensa crucial a su aplicación. Esto no solo protege su sitio web, sino también los datos y la privacidad de sus usuarios.",
      "howItWorks": {
        "title": "¿Cómo Funciona esta Herramienta?",
        "body": "Esta herramienta analiza la URL que introduce y comprueba la presencia y la configuración correcta de las cabeceras de seguridad más importantes. Proporcionamos un resumen claro de qué cabeceras están presentes y cuáles faltan. Además, ofrecemos una explicación detallada del propósito de cada cabecera y los riesgos que corre si no está presente. Utilice este análisis para mejorar la seguridad de su sitio web."
      },
      "accordion": {
        "hsts": {
          "content": [
            "La cabecera <a href='https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Strict-Transport-Security' target='_blank' rel='noopener noreferrer' class='text-brand-secondary hover:underline'>HTTP Strict Transport Security (HSTS)</a> es una potente medida de seguridad que protege los sitios web contra <a href='https://owasp.org/www-community/attacks/Man-in-the-middle_attack' target='_blank' rel='noopener noreferrer' class='text-brand-secondary hover:underline'>ataques de intermediario</a>, como los ataques de degradación de protocolo y el secuestro de cookies. En esencia, es una instrucción del servidor web al navegador para que se comunique exclusivamente a través de una conexión HTTPS segura y cifrada, y nunca a través del inseguro HTTP. El navegador recuerda esta instrucción durante un período especificado por el sitio web.",
            "El principal peligro que HSTS aborda es el 'SSL stripping'. Imagine a un usuario conectándose a una red Wi-Fi pública en una cafetería. Un atacante en la misma red puede interceptar la primera solicitud HTTP no segura del usuario. Incluso si el sitio web normalmente redirige a HTTPS, el atacante puede bloquear esta redirección y mantener una conexión no cifrada con el usuario, mientras establece una conexión cifrada con el servidor. El usuario no nota nada, pero el atacante ahora puede leer todo el tráfico, incluidas las contraseñas y los datos personales, en texto plano. HSTS evita este escenario por completo. Una vez que un navegador ha recibido la cabecera HSTS de un dominio, convertirá automática e internamente todos los futuros intentos de conexión a través de HTTP a HTTPS, antes de que la solicitud salga de la red. El atacante simplemente nunca tiene la oportunidad de interceptar la conexión.",
            "La implementación de HSTS se realiza a través de la propia cabecera, que puede contener varias directivas. La más importante es `max-age`, que especifica en segundos cuánto tiempo debe recordar el navegador la regla HSTS. Un valor típico recomendado es 31536000, que corresponde a un año. Otra directiva potente es `includeSubDomains`. Si está presente, la regla HSTS no solo se aplica al dominio principal (por ejemplo, `www.ejemplo.es`), sino también a todos los subdominios (como `blog.ejemplo.es` y `api.ejemplo.es`). Esta es una adición crucial, pero requiere que todos los subdominios sean totalmente accesibles a través de HTTPS. La máxima protección la proporciona la directiva `preload`. Si un sitio web cumple con requisitos estrictos, puede ser incluido en la <a href='https://hstspreload.org/' target='_blank' rel='noopener noreferrer' class='text-brand-secondary hover:underline'>'lista de precarga HSTS'</a>, una lista que está codificada en los principales navegadores como Chrome, Firefox y Safari. Esto significa que incluso la primera conexión de un usuario al sitio web se fuerza inmediatamente a HTTPS, sin dejar ninguna ventana de vulnerabilidad."
          ]
        },
        "csp": {
          "content": [
            "La <a href='https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP' target='_blank' rel='noopener noreferrer' class='text-brand-secondary hover:underline'>Content-Security-Policy (CSP)</a> es uno de los mecanismos de defensa más potentes y esenciales contra una amplia gama de ataques de inyección de contenido, con el objetivo principal de mitigar el <a href='https://owasp.org/www-community/attacks/xss/' target='_blank' rel='noopener noreferrer' class='text-brand-secondary hover:underline'>Cross-Site Scripting (XSS)</a>. En pocas palabras, la CSP permite a un administrador de sitio web definir una 'lista blanca' estricta de fuentes de confianza. Solo el contenido que se origine en estos dominios explícitamente aprobados puede ser cargado y ejecutado por el navegador. Esto incluye scripts, hojas de estilo, imágenes, fuentes, iframes y más. Todo lo que no esté en esta lista es bloqueado sin piedad por el navegador, reduciendo drásticamente la superficie de ataque para vulnerabilidades comunes.",
            "Para entender el poder de la CSP, primero hay que entender la amenaza del XSS. Un ataque XSS ocurre cuando un atacante logra inyectar código malicioso, generalmente JavaScript, en un sitio web legítimo. Esto puede ocurrir a través de un campo de comentarios, una barra de búsqueda o una URL manipulada. Cuando otro usuario visita la página infectada, este script se ejecuta en su navegador con los mismos permisos que el propio sitio web. El atacante puede usar esto para robar cookies de sesión, capturar pulsaciones de teclas, modificar visualmente la página o redirigir al usuario a un sitio de phishing. La CSP ataca este problema de raíz. Incluso si un atacante inyecta un script malicioso, una CSP bien configurada instruirá al navegador para que no lo ejecute porque no proviene de una fuente aprobada. Por defecto, la CSP también bloquea los scripts en línea y las funciones de tipo `eval()`, que son técnicas comunes en los ataques XSS.",
            "La configuración de una CSP se realiza a través de una serie de 'directivas' en el valor de la cabecera. Cada directiva gestiona un tipo específico de contenido. Por ejemplo, `script-src` determina qué fuentes pueden suministrar scripts, `style-src` controla las hojas de estilo y `img-src` gestiona las imágenes. La directiva `default-src` actúa como un respaldo para la mayoría de las otras directivas. Los valores de fuente comunes son `'self'` (que se refiere al propio dominio), dominios específicos (como `https://apis.google.com`) y `'none'` (que no permite nada). La implementación de una CSP requiere una planificación cuidadosa, ya que una política demasiado estricta puede romper la funcionalidad legítima. Por lo tanto, la CSP también ofrece un modo `report-only`. En este modo, las violaciones no se bloquean, sino que se envía un informe a una URL especificada por el desarrollador a través de la directiva `report-uri` o `report-to`. Esto permite a los equipos probar y afinar su política en un entorno de producción sin interrumpir la experiencia del usuario."
          ]
        },
        "xcto": {
          "content": [
            "La cabecera <a href='https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Content-Type-Options' target='_blank' rel='noopener noreferrer' class='text-brand-secondary hover:underline'>`X-Content-Type-Options`</a> es una medida de seguridad aparentemente simple, pero extremadamente efectiva, que bloquea un vector de ataque específico e insidioso: el 'MIME type sniffing'. Con un único valor posible y válido, `nosniff`, esta cabecera da una instrucción clara e inequívoca al navegador: confía en la cabecera `Content-Type` enviada por el servidor y bajo ninguna circunstancia intentes adivinar por ti mismo qué tipo de archivo estás recibiendo. Esta simple regla es una defensa fundamental contra una clase de ataques que explotan la tendencia de los navegadores a ser 'serviciales'.",
            "El núcleo del problema es el <a href='https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types#mime_sniffing' target='_blank' rel='noopener noreferrer' class='text-brand-secondary hover:underline'>'MIME sniffing'</a>. Los servidores web envían una cabecera `Content-Type` con cada archivo para decirle al navegador qué es (por ejemplo, `text/html`, `image/jpeg`, `application/javascript`). Sin embargo, los navegadores más antiguos a veces intentaban ser más listos que el servidor. Por ejemplo, si un servidor enviaba un archivo con `Content-Type: text/plain`, pero el contenido parecía HTML, el navegador podría decidir renderizarlo como HTML de todos modos. Aunque esto tenía la intención de corregir servidores mal configurados, creó una peligrosa vulnerabilidad. Un atacante puede explotar esto subiendo un archivo que parece inofensivo a primera vista pero que en realidad contiene código malicioso.",
            "Un escenario de ataque clásico es el siguiente: un atacante sube un archivo a un sitio web, por ejemplo, como foto de perfil. Este archivo tiene una extensión `.jpg` y contiene datos de imagen válidos, pero también hay código JavaScript malicioso oculto en su interior. El servidor ve la extensión `.jpg`, confía en ella y sirve el archivo con `Content-Type: image/jpeg`. Cuando una víctima ve esta 'imagen', un navegador sin la instrucción `nosniff` podría inspeccionar el archivo. El navegador detecta el código JavaScript y decide, a pesar de la cabecera `Content-Type`, que es un script y lo ejecuta. Dado que este script se ejecuta en el contexto del sitio web, tiene acceso a la sesión del usuario, lo que puede llevar a una toma de control completa de la cuenta a través de Cross-Site Scripting (XSS).",
            "La cabecera `X-Content-Type-Options: nosniff` detiene este ataque por completo. El navegador recibe ahora la orden explícita: 'Si el servidor dice que esto es un `image/jpeg`, trátalo como una imagen y nada más'. El navegador ya no intentará 'olfatear' el contenido e ignorará el código JavaScript oculto. La implementación es trivial: es simplemente añadir una única cabecera a todas las respuestas del servidor. Es un ejemplo perfecto de un principio de 'defensa en profundidad': incluso si otras capas de seguridad (como la validación de archivos al subirlos) fallan, esta cabecera proporciona una robusta línea de defensa final. Es una medida esencial y de bajo esfuerzo que debería estar presente en todo sitio web moderno."
          ]
        },
        "xfo": {
          "content": [
            "La cabecera <a href='https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Frame-Options' target='_blank' rel='noopener noreferrer' class='text-brand-secondary hover:underline'>`X-Frame-Options`</a> es una medida de seguridad crucial diseñada específicamente para prevenir un ataque insidioso llamado <a href='https://owasp.org/www-community/attacks/Clickjacking' target='_blank' rel='noopener noreferrer' class='text-brand-secondary hover:underline'>'clickjacking'</a>. El clickjacking, también conocido como 'ataque de reparación de interfaz de usuario', es una técnica en la que un atacante engaña a un usuario para que haga clic en algo diferente de lo que percibe. Esto se logra generalmente superponiendo una página web invisible o transparente (o parte de ella) en un iframe sobre la página visible. El usuario cree que está haciendo clic en un botón inofensivo, como 'Ganar un premio', pero en realidad, su clic se registra en la página invisible de debajo, por ejemplo, en un botón de 'Eliminar mi cuenta' de un sitio web en el que está conectado en ese momento.",
            "La cabecera `X-Frame-Options` proporciona una forma simple pero efectiva de controlar si un navegador puede renderizar una página dentro de elementos de incrustación como marcos o iframes. Al incluir esta cabecera en la respuesta HTTP de una página web, el servidor puede instruir al navegador sobre cómo manejar dichas solicitudes. Hay dos directivas de uso común y una obsoleta. La opción más restrictiva y segura es `DENY`. Este valor prohíbe completamente la renderización de la página en un marco, independientemente del sitio web que lo intente. Esta es la mejor opción para páginas con acciones muy sensibles que nunca deberían ser incrustadas, como las páginas de cambio de contraseña o las páginas de transacciones financieras.",
            "Una opción más flexible y muy común es `SAMEORIGIN`. Esta directiva permite que la página se renderice en un marco, pero solo si el sitio web que intenta incrustar la página tiene el mismo origen (dominio) que la propia página. Esto es particularmente útil para aplicaciones web que utilizan iframes para su propia funcionalidad legítima, como mostrar ventanas modales o integrar diferentes partes de la misma aplicación, mientras se evita la incrustación por parte de sitios web externos y potencialmente maliciosos. una tercera opción obsoleta es `ALLOW-FROM uri`, que permitía especificar una URL concreta que podía enmarcar la página. Sin embargo, esta opción nunca fue ampliamente soportada por todos los navegadores y ahora se considera obsoleta.",
            "Aunque `X-Frame-Options` sigue siendo muy relevante y eficaz, es importante señalar que la más moderna `Content-Security-Policy` (CSP) incluye una directiva <a href='https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/frame-ancestors' target='_blank' rel='noopener noreferrer' class='text-brand-secondary hover:underline'>`frame-ancestors`</a>. Esta directiva se considera la sucesora de `X-Frame-Options` ya que ofrece más flexibilidad (como la especificación de múltiples dominios permitidos). Sin embargo, debido a su amplio soporte y simplicidad, la implementación de `X-Frame-Options` sigue siendo una estrategia de 'defensa en profundidad' recomendada, especialmente para garantizar la compatibilidad con navegadores más antiguos. Al configurar correctamente esta cabecera, se neutraliza eficazmente toda una clase de ataques basados en la interfaz de usuario."
          ]
        },
        "rp": {
          "content": [
            "La cabecera <a href='https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Referrer-Policy' target='_blank' rel='noopener noreferrer' class='text-brand-secondary hover:underline'>`Referrer-Policy`</a> es un instrumento esencial para proteger la privacidad de los usuarios al controlar qué información se envía en la cabecera `Referer` (nótese el error ortográfico histórico) cuando un usuario navega de una página a otra. Por defecto, un navegador envía la URL completa de la página anterior a la nueva página. Si bien esto es útil para la analítica y para entender los flujos de tráfico, crea un riesgo de privacidad significativo. Las URL pueden contener información sensible, como términos de búsqueda, identificadores de usuario o incluso tokens de restablecimiento de contraseña. El envío de estos datos a terceros sin el conocimiento del usuario es una fuga de datos que puede ser explotada.",
            "La `Referrer-Policy` permite a los propietarios de sitios web controlar con precisión este comportamiento utilizando diversas directivas. La elección de una directiva es un equilibrio entre la privacidad y la funcionalidad. Una de las opciones más estrictas es `no-referrer`. Como su nombre indica, la cabecera `Referer` se omite por completo en todas las solicitudes salientes en este caso. Esto proporciona la máxima privacidad, pero imposibilita que el sitio receptor vea de dónde proviene el tráfico, lo que puede complicar el análisis de las fuentes de tráfico. Otra opción común y respetuosa con la privacidad es `strict-origin-when-cross-origin`. A menudo es una buena opción por defecto. Se comporta de la siguiente manera: para la navegación dentro del mismo sitio web (por ejemplo, de `ejemplo.es/pagina1` a `ejemplo.es/pagina2`), se envía la URL completa. Sin embargo, para la navegación a otro sitio web (cross-origin), solo se envía la URL base (el origen, por ejemplo, `https://ejemplo.es/`), y solo si la conexión es igualmente segura (HTTPS a HTTPS).",
            "Otras directivas ofrecen un control más granular. `same-origin` asegura que el referente solo se envíe para solicitudes dentro del mismo sitio web; se omite para todas las demás solicitudes. `strict-origin` envía solo la URL base, pero a diferencia de `strict-origin-when-cross-origin`, también lo hace para la navegación dentro del mismo sitio. En el otro extremo del espectro se encuentra `unsafe-url`, que, como su nombre indica, no es seguro. Esta directiva siempre envía la URL completa, incluidos los parámetros de consulta, incluso en solicitudes no seguras (HTTP). Su uso está fuertemente desaconsejado. Al elegir conscientemente una `Referrer-Policy`, los propietarios de sitios web asumen la responsabilidad de los datos de sus usuarios. La implementación de una política restrictiva, como `strict-origin-when-cross-origin`, es un paso simple que mejora significativamente la privacidad sin romper la funcionalidad esencial."
          ]
        },
        "pp": {
          "content": [
            "La cabecera <a href='https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Permissions-Policy' target='_blank' rel='noopener noreferrer' class='text-brand-secondary hover:underline'>`Permissions-Policy`</a> es una característica de seguridad moderna y potente que otorga a los administradores de sitios web un control detallado sobre qué características y API del navegador se pueden utilizar en una página. Esta cabecera, que reemplaza a la antigua `Feature-Policy`, se basa en el 'principio de privilegio mínimo': un fragmento de código solo debe tener los permisos absolutamente necesarios para realizar su tarea. Al definir explícitamente qué características están permitidas, los desarrolladores pueden reducir significativamente la 'superficie de ataque' de su sitio web y proteger mejor la privacidad del usuario.",
            "Las aplicaciones web modernas utilizan cada vez más potentes API del navegador, como el acceso a la cámara (`camera`), el micrófono (`microphone`), la geolocalización (`geolocation`), el modo de pantalla completa (`fullscreen`) y el procesamiento de pagos (`payment`). Si bien estas características permiten experiencias de usuario innovadoras, también plantean un riesgo potencial. Una vulnerabilidad en un script de terceros, como un script de publicidad o de análisis cargado en su página, podría ser explotada para obtener acceso no deseado a estas API sensibles. Por ejemplo, a un usuario se le podría solicitar sin saberlo que conceda acceso al micrófono a un script no confiable que se aprovecha de su sitio web legítimo.",
            "La `Permissions-Policy` aborda este problema especificando una política clara. La cabecera consta de una serie de directivas, donde cada directiva representa una característica específica. Para cada característica, se puede especificar una lista de 'orígenes' (dominios) permitidos. Por ejemplo, si un sitio web no necesita acceso al micrófono, el desarrollador puede deshabilitarlo explícitamente con `permissions-policy: microphone=()`. Los paréntesis vacíos `()` significan que la característica está deshabilitada para todas las partes (incluido el propio sitio y todos los iframes). Si una característica solo debe ser utilizada por el propio sitio web, se puede configurar con `microphone=('self')`. Esto asegura que los iframes incrustados de terceros, como un video de YouTube, no puedan solicitar acceso al micrófono.",
            "El verdadero poder de `Permissions-Policy` reside en su control granular sobre el contenido de terceros. Puede otorgar permiso a un dominio específico, por ejemplo, `permissions-policy: camera=('self' https://trusted-partner.com)`. Esto asegura que solo su propio sitio y un socio de confianza puedan usar la cámara. Todos los demás iframes serán bloqueados. La implementación de una `Permissions-Policy` estricta es una de las mejores prácticas para el desarrollo web moderno. Obliga a los desarrolladores a pensar conscientemente en qué funcionalidad necesita realmente su aplicación y proporciona una capa de defensa robusta contra el abuso de las API del navegador. Esto se traduce en una experiencia más segura para el usuario y fortalece la confianza en su plataforma."
          ]
        },
        "xxp": {
          "content": [
            "La cabecera <a href='https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-XSS-Protection' target='_blank' rel='noopener noreferrer' class='text-brand-secondary hover:underline'>`X-XSS-Protection`</a> es una pieza de la historia de Internet; una medida de seguridad introducida en su día en navegadores como Internet Explorer, Chrome y Safari como primera línea de defensa contra los ataques de Cross-Site Scripting (XSS) 'reflejados'. Aunque la intención era buena, la cabecera está ahora obsoleta y es desaprobada e incluso ignorada por todos los navegadores modernos. Su funcionalidad ha sido completamente reemplazada por la `Content-Security-Policy` (CSP), mucho más robusta y configurable. Sin embargo, comprender el funcionamiento y las deficiencias de `X-XSS-Protection` proporciona una valiosa visión de la evolución de la seguridad web.",
            "La cabecera fue diseñada para bloquear un vector de ataque específico: un <a href='https://owasp.org/www-community/attacks/xss/#reflected-xss-attacks' target='_blank' rel='noopener noreferrer' class='text-brand-secondary hover:underline'>ataque XSS 'reflejado'</a>. Este tipo de ataque ocurre cuando el código malicioso, a través de un parámetro de URL o una entrada de formulario, es 'reflejado' por el servidor e incluido directamente en la respuesta HTML. La cabecera `X-XSS-Protection` activaba un 'auditor' o 'filtro' incorporado en el navegador. Este filtro utilizaba heurísticas para detectar si el código de script en la solicitud (por ejemplo, en la URL) también aparecía literalmente en el HTML de la página. Si era así, el navegador concluía que se estaba produciendo un ataque.",
            "La cabecera podía tener varios valores. El valor por defecto era `1`, que activaba el filtro. Al detectar un ataque, el navegador intentaba 'sanear' la página eliminando o neutralizando el código malicioso. Sin embargo, este enfoque resultó ser peligroso. Los atacantes descubrieron formas de eludir estos mecanismos de saneamiento y, en algunos casos, incluso pudieron crear vulnerabilidades que no existían sin el filtro. Una opción más segura era `1; mode=block`. En este modo, al detectar un ataque, el navegador dejaría de renderizar la página por completo y mostraría una página en blanco. Esto evitaba la ejecución del script pero proporcionaba una mala experiencia de usuario. El valor `0` desactivaba explícitamente el filtro.",
            "Finalmente, la cabecera fue desaprobada por varias razones. Los filtros no eran fiables, podían ser eludidos y a veces causaban 'falsos positivos' que rompían sitios web legítimos. Más importante aún, el auge de la `Content-Security-Policy` ofreció un enfoque fundamentalmente superior. En lugar de intentar 'adivinar' los ataques basándose en heurísticas poco fiables, la CSP permite a los desarrolladores definir una 'lista blanca' estricta de fuentes de código de confianza. Este modelo de 'denegación por defecto' es inherentemente más seguro. Aunque todavía puede encontrar la cabecera `X-XSS-Protection` en sitios web más antiguos, ya no se considera una medida de seguridad activa para el desarrollo web moderno. El enfoque ahora está completamente en una CSP fuerte y bien configurada."
          ]
        }
      }
    }
  }
};
